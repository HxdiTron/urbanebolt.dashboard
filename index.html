<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UrbaneBolt • Operations Dashboard</title>
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
    <link rel="shortcut icon" type="image/x-icon" href="assets/favicon.ico">
    <!-- Tailwind: for production build use PostCSS/CLI (https://tailwindcss.com/docs/installation) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script>
    <!-- Charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <!-- SheetJS for Excel parsing -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="api.js"></script>
    <script src="config.js"></script>
    <style>
        html { scroll-behavior: smooth; }
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #e2e8f0; border-radius: 3px; }
        .insights-flow { overflow-x: auto; overflow-y: hidden; scroll-snap-type: x mandatory; -webkit-overflow-scrolling: touch; scrollbar-width: thin; }
        .insights-flow::-webkit-scrollbar { height: 8px; }
        .insights-flow .insight-card { scroll-snap-align: start; scroll-snap-stop: normal; min-width: min(320px, 100%); }
        @media (min-width: 1024px) { .insights-flow { overflow-x: visible; scroll-snap-type: none; } }
        .premium-shadow { box-shadow: 0 2px 10px rgba(0,0,0,0.02), 0 10px 25px rgba(0,0,0,0.03); }
        .premium-border { border: 1px solid #e2e8f0; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .animate-spin { animation: spin 1s linear infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        .status-delivered { background-color: #d1fae5; color: #047857; }
        .status-intransit { background-color: #dbeafe; color: #1d4ed8; }
        .status-ofd { background-color: #fef3c7; color: #b45309; }
        .status-rto { background-color: #fee2e2; color: #dc2626; }
        .status-ndr { background-color: #ffedd5; color: #c2410c; }
        .status-cancelled { background-color: #f1f5f9; color: #475569; }
        .row-delivered { border-left: 3px solid #10b981; }
        .row-intransit { border-left: 3px solid #3b82f6; }
        .row-ofd { border-left: 3px solid #f59e0b; }
        .row-exception { border-left: 3px solid #ef4444; }
        
        /* Filter Chips */
        .status-chip {
            background-color: #f1f5f9;
            color: #64748b;
            border: 1px solid transparent;
        }
        .status-chip:hover {
            background-color: #e2e8f0;
            color: #475569;
        }
        .status-chip.active {
            background-color: #1e293b;
            color: white;
            border-color: #1e293b;
        }
        .status-chip.failure-chip:hover {
            background-color: #fef2f2;
            border-color: #fecaca;
            color: #dc2626;
        }
        .status-chip.failure-chip.active {
            background-color: #dc2626;
            border-color: #dc2626;
            color: white;
        }
        
        /* Delay indicator styles */
        .delay-positive { color: #059669; background-color: #d1fae5; }
        .delay-negative { color: #dc2626; background-color: #fee2e2; font-weight: 600; }
        .delay-neutral { color: #64748b; background-color: #f1f5f9; }
        
        /* SLA Badge styles */
        .sla-ontime { background-color: #d1fae5; color: #047857; }
        .sla-delayed { background-color: #fee2e2; color: #dc2626; }
        .sla-breach { background-color: #fef3c7; color: #b45309; }
        .sla-critical { background: linear-gradient(135deg, #fee2e2, #fef3c7); color: #dc2626; animation: pulse 2s infinite; }
        
        .dashboard-scroll { scroll-behavior: smooth; }
        /* Row highlight for failures */
        .row-failure { 
            background-color: #fef2f2 !important; 
            border-left: 3px solid #dc2626;
        }
        .row-breach {
            background-color: #fffbeb !important;
            border-left: 3px solid #f59e0b;
        }
        
        /* Select dropdown styling */
        select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
    </style>
</head>
<body class="text-slate-600 antialiased h-screen flex overflow-hidden">

    <!-- Sidebar -->
    <aside class="w-64 bg-white border-r border-slate-200 flex flex-col justify-between z-20 hidden lg:flex">
        <div>
            <div class="h-16 flex items-center px-5 border-b border-slate-100">
                <div class="flex items-center gap-3">
                    <img src="assets/favicon.ico" alt="UrbaneBolt" class="w-9 h-9 rounded-lg object-contain">
                    <div class="flex flex-col">
                        <span class="font-bold tracking-tight text-slate-900 text-sm">URBANEBOLT</span>
                        <span class="text-[10px] font-medium text-slate-400 tracking-wider uppercase">Operations</span>
                    </div>
                </div>
            </div>

            <nav class="p-3 space-y-1">
                <div class="px-3 pb-2 pt-3">
                    <p class="text-[10px] font-semibold text-slate-400 uppercase tracking-widest">Dashboard</p>
                </div>
                
                <a href="index.html" class="flex items-center gap-3 px-3 py-2.5 text-sm font-medium rounded-lg bg-slate-900 text-white">
                    <iconify-icon icon="solar:widget-2-linear" width="18"></iconify-icon>
                    Overview
                </a>
                
                <div class="px-3 pb-2 pt-5">
                    <p class="text-[10px] font-semibold text-slate-400 uppercase tracking-widest">Finance & NDR</p>
                </div>

                <a href="cod.html" class="flex items-center gap-3 px-3 py-2.5 text-sm font-medium rounded-lg hover:bg-slate-50 text-slate-600">
                    <iconify-icon icon="solar:bill-list-linear" width="18"></iconify-icon>
                    COD Reconciliation
                </a>
                
                <a href="exceptions.html" class="flex items-center gap-3 px-3 py-2.5 text-sm font-medium rounded-lg hover:bg-slate-50 text-slate-600">
                    <iconify-icon icon="solar:danger-triangle-linear" width="18"></iconify-icon>
                    RTO & Exceptions
                    <span id="exceptionBadge" class="ml-auto bg-rose-100 text-rose-600 py-0.5 px-2 rounded-full text-[10px] font-semibold hidden">0</span>
                </a>
            </nav>
        </div>

        <div class="p-3 border-t border-slate-100">
            <div class="flex items-center gap-3 p-2 rounded-lg hover:bg-slate-50">
                <img src="https://ui-avatars.com/api/?name=Hub+Manager&background=0f172a&color=fff" alt="User" class="w-8 h-8 rounded-full">
                <div class="flex flex-col">
                    <span class="text-xs font-semibold text-slate-900">Hub Manager</span>
                    <span class="text-[10px] text-slate-500">Operations</span>
                </div>
            </div>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col h-full overflow-hidden bg-slate-50">
        
        <!-- Top Bar -->
        <header class="bg-white border-b border-slate-200 px-6 py-4">
            <div class="flex items-center justify-between mb-4">
            <div class="flex items-center gap-4">
                    <h1 class="text-xl font-bold text-slate-900">Operations Dashboard</h1>
                    <div id="connectionStatus" class="flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-slate-100 text-slate-500">
                        <span class="w-2 h-2 rounded-full bg-slate-400"></span>
                        <span>Initializing...</span>
                    </div>
                    <div id="rateLimitStatus" class="flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-blue-50 text-blue-600 hidden">
                        <iconify-icon icon="solar:shield-check-linear" width="12"></iconify-icon>
                        <span>0/60 req/min</span>
                    </div>
                </div>
                <div class="flex items-center gap-2 text-xs text-slate-500">
                    <iconify-icon icon="solar:calendar-linear" width="14"></iconify-icon>
                    <span id="currentDate"></span>
                </div>
            </div>
            
            <!-- Manual AWB Search & Excel Upload -->
            <div class="bg-white border border-slate-200 rounded-2xl p-4 shadow-sm">
                <div class="flex flex-wrap items-center gap-3">
                    <!-- Single AWB Search -->
                    <div class="relative flex-1 min-w-[200px] max-w-sm">
                        <iconify-icon icon="solar:magnifer-linear" width="16" class="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400"></iconify-icon>
                        <input type="text" id="awbSearchInput" 
                            placeholder="Search AWB..." 
                            class="w-full text-sm bg-slate-50 border-0 rounded-lg pl-9 pr-4 py-2.5 font-mono placeholder:font-sans focus:ring-2 focus:ring-blue-500 focus:bg-white outline-none transition-all">
                    </div>
                    <button onclick="trackSingleAWB()" id="trackBtn"
                        class="px-4 py-2.5 text-sm font-semibold text-white bg-slate-900 rounded-lg hover:bg-slate-800 flex items-center gap-2 transition-all">
                        <iconify-icon icon="solar:magnifer-linear" width="14"></iconify-icon>
                        Search
                    </button>
                    
                    <div class="h-8 w-px bg-slate-200 hidden md:block"></div>
                    
                    <!-- Bulk Input -->
                    <input type="text" id="bulkAwbInput" placeholder="Bulk: AWB1, AWB2..." 
                        class="flex-1 min-w-[150px] text-sm bg-slate-50 border-0 rounded-lg px-3 py-2.5 font-mono placeholder:font-sans focus:ring-2 focus:ring-blue-500 outline-none hidden md:block">
                    <button onclick="trackBulkAWB()" id="bulkTrackBtn"
                        class="px-3 py-2.5 text-sm font-medium text-slate-600 bg-slate-100 rounded-lg hover:bg-slate-200 transition-all hidden md:flex items-center gap-1">
                        <iconify-icon icon="solar:layers-linear" width="14"></iconify-icon>
                        Bulk
                    </button>
                    
                    <div class="h-8 w-px bg-slate-200 hidden md:block"></div>
                    
                    <!-- Import Excel: single button → file input → POST /api/v1/upload → MongoDB → refresh dashboard -->
                    <input type="file" id="mongoUploadInput" accept=".xlsx,.xls,.csv" class="hidden" onchange="handleUploadToMongo(event)">
                    <button onclick="document.getElementById('mongoUploadInput').click()" id="mongoUploadBtn"
                        class="px-4 py-2.5 text-sm font-semibold text-emerald-700 bg-emerald-50 border border-emerald-200 rounded-lg hover:bg-emerald-100 transition-all flex items-center gap-2">
                        <iconify-icon icon="solar:file-text-linear" width="16"></iconify-icon>
                        <span class="hidden sm:inline">Import Excel</span>
                        <span class="sm:hidden">Excel</span>
                    </button>
                    <!-- Optional: client-side Excel import (column picker, no server) -->
                    <input type="file" id="excelFileInput" accept=".xlsx,.xls,.csv" class="hidden" onchange="handleExcelUpload(event)">
                    <button onclick="document.getElementById('excelFileInput').click()"
                        class="px-4 py-2.5 text-sm font-medium text-slate-600 bg-slate-100 border border-slate-200 rounded-lg hover:bg-slate-200 transition-all flex items-center gap-2">
                        <iconify-icon icon="solar:upload-linear" width="16"></iconify-icon>
                        <span class="hidden sm:inline">Import from file (client)</span>
                        <span class="sm:hidden">File</span>
                    </button>
                </div>
                
                <!-- Excel Upload Progress/Preview (Hidden by default) -->
                <div id="excelUploadPanel" class="hidden mt-4 p-4 bg-slate-50 rounded-xl border border-slate-200">
                    <div class="flex items-center justify-between mb-3">
                        <div class="flex items-center gap-2">
                            <iconify-icon icon="solar:file-check-linear" width="20" class="text-emerald-600"></iconify-icon>
                            <span id="excelFileName" class="text-sm font-medium text-slate-900">file.xlsx</span>
                        </div>
                        <button onclick="closeExcelPanel()" class="text-slate-400 hover:text-slate-600">
                            <iconify-icon icon="solar:close-circle-linear" width="18"></iconify-icon>
                        </button>
                    </div>
                    
                    <!-- Column Selection -->
                    <div id="excelColumnSelect" class="mb-4">
                        <label class="block text-[10px] font-semibold text-slate-500 uppercase mb-2">Select AWB Column</label>
                        <div id="excelColumns" class="flex flex-wrap gap-2">
                            <!-- Column buttons will be inserted here -->
                        </div>
                    </div>
                    
                    <!-- Preview -->
                    <div id="excelPreview" class="mb-4">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-[10px] font-semibold text-slate-500 uppercase">Preview (first 10)</span>
                            <span id="excelAwbCount" class="text-xs text-slate-500">0 AWBs found</span>
                        </div>
                        <div id="excelAwbPreview" class="flex flex-wrap gap-1.5 max-h-20 overflow-y-auto">
                            <!-- AWB chips will be inserted here -->
                        </div>
                    </div>
                    
                    <!-- Large file warning -->
                    <div id="excelLargeFileWarning" class="hidden mb-4 p-3 bg-amber-50 border border-amber-200 rounded-lg">
                        <div class="flex items-start gap-2">
                            <iconify-icon icon="solar:info-circle-linear" width="18" class="text-amber-600 mt-0.5"></iconify-icon>
                            <div>
                                <p class="text-xs font-semibold text-amber-800">Large file detected</p>
                                <p class="text-[10px] text-amber-700 mt-0.5">
                                    <span id="excelEtaEstimate">~X minutes</span> estimated. 
                                    You can pause/resume during import. Data saves automatically every 5 batches.
                                </p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Actions -->
                    <div class="flex items-center justify-between pt-3 border-t border-slate-200">
                        <div class="flex flex-col gap-2">
                            <label class="flex items-center gap-2">
                                <input type="checkbox" id="excelFullDataMode" class="rounded border-slate-300 text-emerald-600 focus:ring-emerald-500" checked onchange="onExcelModeToggle()">
                                <span class="text-xs text-slate-700 font-medium">This Excel already contains shipment data (skip API)</span>
                            </label>
                            <label class="flex items-center gap-2">
                                <input type="checkbox" id="excelSetAsLiveRange" class="rounded border-slate-300 text-emerald-600 focus:ring-emerald-500">
                                <span class="text-xs text-slate-600">Use as Live Board range</span>
                            </label>
                        </div>
                        <div class="flex gap-2">
                            <button onclick="closeExcelPanel()" class="px-3 py-2 text-xs font-medium text-slate-600 bg-slate-100 rounded-lg hover:bg-slate-200 transition-all">
                                Cancel
                            </button>
                            <button onclick="trackExcelAwbs()" id="trackExcelBtn" class="px-4 py-2 text-xs font-semibold text-white bg-emerald-600 rounded-lg hover:bg-emerald-700 transition-all flex items-center gap-2">
                                <iconify-icon icon="solar:play-linear" width="14"></iconify-icon>
                                Import <span id="excelTrackCount">0</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- FILTERS SECTION -->
            <div class="bg-white border border-slate-200 rounded-2xl p-4 shadow-sm mt-4">
                <!-- Quick Status Filters (Chips) -->
                <div class="flex flex-wrap items-center gap-2 mb-4">
                    <span class="text-xs font-medium text-slate-500 mr-2">Quick filters:</span>
                    <button onclick="setStatusFilter('ALL')" data-status="ALL" class="status-chip active px-3 py-1.5 text-xs font-medium rounded-full transition-all">
                        All
                    </button>
                    <button onclick="setStatusFilter('FAILURE')" data-status="FAILURE" class="status-chip failure-chip px-3 py-1.5 text-xs font-medium rounded-full transition-all border border-transparent">
                        <span class="inline-block w-2 h-2 rounded-full bg-rose-500 mr-1.5 animate-pulse"></span>
                        Failures
                        <span id="failureChipCount" class="ml-1 text-[10px] bg-rose-100 text-rose-700 px-1.5 py-0.5 rounded-full hidden">0</span>
                    </button>
                    <button onclick="setStatusFilter('DELAYED')" data-status="DELAYED" class="status-chip px-3 py-1.5 text-xs font-medium rounded-full transition-all">
                        <span class="inline-block w-2 h-2 rounded-full bg-orange-500 mr-1.5"></span>
                        Delayed
                    </button>
                    <button onclick="setStatusFilter('DELIVERED')" data-status="DELIVERED" class="status-chip px-3 py-1.5 text-xs font-medium rounded-full transition-all">
                        <span class="inline-block w-2 h-2 rounded-full bg-emerald-500 mr-1.5"></span>
                        Delivered
                    </button>
                    <button onclick="setStatusFilter('INTRANSIT')" data-status="INTRANSIT" class="status-chip px-3 py-1.5 text-xs font-medium rounded-full transition-all">
                        <span class="inline-block w-2 h-2 rounded-full bg-blue-500 mr-1.5"></span>
                        In Transit
                    </button>
                    <button onclick="setStatusFilter('OFD')" data-status="OFD" class="status-chip px-3 py-1.5 text-xs font-medium rounded-full transition-all">
                        <span class="inline-block w-2 h-2 rounded-full bg-amber-500 mr-1.5"></span>
                        OFD
                    </button>
                    <button onclick="setStatusFilter('RTO')" data-status="RTO" class="status-chip px-3 py-1.5 text-xs font-medium rounded-full transition-all">
                        <span class="inline-block w-2 h-2 rounded-full bg-rose-500 mr-1.5"></span>
                        RTO
                    </button>

                    <!-- Divider -->
                    <span class="h-5 w-px bg-slate-200 mx-2 hidden sm:inline-block"></span>

                    <!-- Type quick chips -->
                    <div class="flex flex-wrap items-center gap-1">
                        <span class="text-[10px] font-semibold text-slate-400 uppercase tracking-wider mr-1">Type</span>
                        <button onclick="setTypeQuickFilter('ALL')" data-type="ALL" class="status-chip type-chip active px-2.5 py-1 text-[11px] font-medium rounded-full transition-all">
                            All
                        </button>
                        <button onclick="setTypeQuickFilter('COD')" data-type="COD" class="status-chip type-chip px-2.5 py-1 text-[11px] font-medium rounded-full transition-all">
                            COD
                        </button>
                        <button onclick="setTypeQuickFilter('PPD')" data-type="PPD" class="status-chip type-chip px-2.5 py-1 text-[11px] font-medium rounded-full transition-all">
                            PPD
                        </button>
                    </div>

                    <!-- Customer quick filter -->
                    <div class="flex items-center gap-1 ml-2">
                        <span class="text-[10px] font-semibold text-slate-400 uppercase tracking-wider">Customer</span>
                        <input
                            id="quickCustomerFilter"
                            type="text"
                            placeholder="Name"
                            oninput="onQuickCustomerFilterChange()"
                            class="text-[11px] px-2 py-1 rounded-lg border border-slate-200 bg-slate-50 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 min-w-[120px]"
                        />
                    </div>

                    <!-- Date quick filter -->
                    <div class="flex items-center gap-1 ml-2">
                        <span class="text-[10px] font-semibold text-slate-400 uppercase tracking-wider">Date</span>
                        <input
                            id="quickDateFilter"
                            type="date"
                            onchange="onQuickDateFilterChange()"
                            class="text-[11px] px-2 py-1 rounded-lg border border-slate-200 bg-slate-50 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                        />
                    </div>
                </div>

                <!-- Advanced Filters Row -->
                <div class="flex flex-wrap items-end gap-3 pt-3 border-t border-slate-100">
                    <!-- Search in Table -->
                    <div class="flex-1 min-w-[200px]">
                        <label class="block text-[10px] font-semibold text-slate-400 uppercase tracking-wider mb-1.5">Search in results</label>
                        <div class="relative">
                            <iconify-icon icon="solar:magnifer-linear" width="14" class="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400"></iconify-icon>
                            <input type="text" id="tableSearchInput" 
                                placeholder="AWB, customer, location..." 
                                oninput="applyFiltersAndRender()"
                                class="w-full text-xs bg-slate-50 border border-slate-200 rounded-lg pl-9 pr-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 focus:bg-white outline-none transition-all">
                        </div>
                    </div>

                    <!-- Type Filter -->
                    <div class="min-w-[130px]">
                        <label class="block text-[10px] font-semibold text-slate-400 uppercase tracking-wider mb-1.5">Type</label>
                        <select id="typeFilter" onchange="applyFiltersAndRender()" class="w-full text-xs bg-slate-50 border border-slate-200 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 focus:bg-white outline-none appearance-none cursor-pointer transition-all">
                            <option value="ALL">All Types</option>
                            <option value="COD">COD</option>
                            <option value="PPD">Prepaid</option>
                        </select>
                    </div>

                    <!-- Origin Filter -->
                    <div class="min-w-[140px]">
                        <label class="block text-[10px] font-semibold text-slate-400 uppercase tracking-wider mb-1.5">Origin</label>
                        <select id="originFilter" onchange="applyFiltersAndRender()" class="w-full text-xs bg-slate-50 border border-slate-200 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 focus:bg-white outline-none appearance-none cursor-pointer transition-all">
                            <option value="ALL">All Origins</option>
                        </select>
                    </div>

                    <!-- Destination Filter -->
                    <div class="min-w-[140px]">
                        <label class="block text-[10px] font-semibold text-slate-400 uppercase tracking-wider mb-1.5">Destination</label>
                        <select id="destinationFilter" onchange="applyFiltersAndRender()" class="w-full text-xs bg-slate-50 border border-slate-200 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 focus:bg-white outline-none appearance-none cursor-pointer transition-all">
                            <option value="ALL">All Destinations</option>
                        </select>
                    </div>

                    <!-- Status Filter (Hidden - controlled by chips) -->
                    <input type="hidden" id="statusFilter" value="ALL">
                    <input type="hidden" id="dateFilter" value="">

                    <!-- Actions -->
                    <div class="flex items-center gap-2 ml-auto">
                        <span id="activeFilterCount" class="hidden text-xs text-blue-600 font-medium bg-blue-50 px-2 py-1 rounded-full"></span>
                        <button onclick="clearFilters()" class="px-3 py-2 text-xs font-medium text-slate-500 hover:text-slate-700 hover:bg-slate-100 rounded-lg transition-all flex items-center gap-1.5">
                            <iconify-icon icon="solar:restart-linear" width="14"></iconify-icon>
                            Reset
                        </button>
                        <button onclick="exportData()" class="px-3 py-2 text-xs font-medium text-slate-700 bg-slate-100 hover:bg-slate-200 rounded-lg transition-all flex items-center gap-1.5">
                            <iconify-icon icon="solar:export-linear" width="14"></iconify-icon>
                            Export
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Scrollable Dashboard Area -->
        <div id="dashboardScroll" class="dashboard-scroll flex-1 overflow-y-auto overflow-x-hidden p-6 space-y-6">
            
            <!-- KPI Cards -->
            <div class="grid grid-cols-2 lg:grid-cols-4 gap-4">
                <div class="bg-white rounded-xl p-5 premium-border premium-shadow">
                    <div class="flex justify-between items-start mb-3">
                        <div class="p-2 bg-blue-50 text-blue-600 rounded-lg">
                            <iconify-icon icon="solar:box-linear" width="20"></iconify-icon>
                        </div>
                        <span class="text-[10px] font-semibold text-slate-400 uppercase">Total</span>
                    </div>
                    <h3 id="kpi-total" class="text-2xl font-bold text-slate-900">0</h3>
                    <p class="text-[10px] text-slate-400 mt-1">Shipments tracked</p>
                </div>

                <div class="bg-white rounded-xl p-5 premium-border premium-shadow">
                    <div class="flex justify-between items-start mb-3">
                        <div class="p-2 bg-emerald-50 text-emerald-600 rounded-lg">
                            <iconify-icon icon="solar:verified-check-linear" width="20"></iconify-icon>
                        </div>
                        <span class="text-[10px] font-semibold text-slate-400 uppercase">Delivered</span>
                    </div>
                    <h3 id="kpi-delivered" class="text-2xl font-bold text-emerald-600">0</h3>
                    <p class="text-[10px] text-slate-400 mt-1">Successfully delivered</p>
                </div>

                <div class="bg-white rounded-xl p-5 premium-border premium-shadow">
                    <div class="flex justify-between items-start mb-3">
                        <div class="p-2 bg-amber-50 text-amber-600 rounded-lg">
                            <iconify-icon icon="solar:delivery-linear" width="20"></iconify-icon>
                        </div>
                        <span class="text-[10px] font-semibold text-slate-400 uppercase">In Transit</span>
                    </div>
                    <h3 id="kpi-intransit" class="text-2xl font-bold text-amber-600">0</h3>
                    <p class="text-[10px] text-slate-400 mt-1">Out for delivery</p>
                </div>

                <div class="bg-white rounded-xl p-5 premium-border premium-shadow">
                    <div class="flex justify-between items-start mb-3">
                        <div class="p-2 bg-rose-50 text-rose-600 rounded-lg">
                            <iconify-icon icon="solar:danger-triangle-linear" width="20"></iconify-icon>
                        </div>
                        <span class="text-[10px] font-semibold text-slate-400 uppercase">Exceptions</span>
                    </div>
                    <h3 id="kpi-exceptions" class="text-2xl font-bold text-rose-600">0</h3>
                    <p class="text-[10px] text-slate-400 mt-1">RTO / NDR / Failed</p>
                </div>
            </div>

            <!-- SLA & Lifecycle KPIs -->
            <div class="grid grid-cols-2 lg:grid-cols-5 gap-4">
                <div class="bg-white rounded-xl p-4 premium-border premium-shadow">
                    <div class="flex items-center gap-3">
                        <div class="p-2 bg-emerald-50 text-emerald-600 rounded-lg">
                            <iconify-icon icon="solar:chart-2-linear" width="18"></iconify-icon>
                        </div>
                        <div>
                            <p class="text-[10px] font-semibold text-slate-400 uppercase">On-Time Rate</p>
                            <h3 id="kpi-dsr" class="text-lg font-bold text-slate-900">0%</h3>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-xl p-4 premium-border premium-shadow">
                    <div class="flex items-center gap-3">
                        <div class="p-2 bg-rose-50 text-rose-600 rounded-lg">
                            <iconify-icon icon="solar:clock-circle-linear" width="18"></iconify-icon>
                        </div>
                        <div>
                            <p class="text-[10px] font-semibold text-slate-400 uppercase">Delayed</p>
                            <h3 id="kpi-delayed" class="text-lg font-bold text-rose-600">0</h3>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-xl p-4 premium-border premium-shadow">
                    <div class="flex items-center gap-3">
                        <div class="p-2 bg-orange-50 text-orange-600 rounded-lg">
                            <iconify-icon icon="solar:danger-triangle-linear" width="18"></iconify-icon>
                        </div>
                        <div>
                            <p class="text-[10px] font-semibold text-slate-400 uppercase">Lifecycle Breach</p>
                            <h3 id="kpi-breach" class="text-lg font-bold text-orange-600">0</h3>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-xl p-4 premium-border premium-shadow">
                    <div class="flex items-center gap-3">
                        <div class="p-2 bg-blue-50 text-blue-600 rounded-lg">
                            <iconify-icon icon="solar:wallet-linear" width="18"></iconify-icon>
                        </div>
                        <div>
                            <p class="text-[10px] font-semibold text-slate-400 uppercase">COD Value</p>
                            <h3 id="kpi-cod" class="text-lg font-bold text-slate-900">₹0</h3>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-xl p-4 premium-border premium-shadow">
                    <div class="flex items-center gap-3">
                        <div class="p-2 bg-violet-50 text-violet-600 rounded-lg">
                            <iconify-icon icon="solar:hourglass-linear" width="18"></iconify-icon>
                        </div>
                        <div>
                            <p class="text-[10px] font-semibold text-slate-400 uppercase">Avg Delay</p>
                            <h3 id="kpi-avgdelay" class="text-lg font-bold text-slate-900">-- days</h3>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Failure Bucket Alert (shown when there are failures) -->
            <div id="failureBucketAlert" class="hidden bg-gradient-to-r from-rose-50 to-orange-50 border border-rose-200 rounded-xl p-4">
                <div class="flex items-start gap-4">
                    <div class="p-2 bg-rose-100 text-rose-600 rounded-lg">
                        <iconify-icon icon="solar:shield-warning-linear" width="24"></iconify-icon>
                    </div>
                    <div class="flex-1">
                        <h3 class="text-sm font-bold text-rose-900">Failure Bucket Alert</h3>
                        <p class="text-xs text-rose-700 mt-1">
                            <span id="failureBucketCount">0</span> shipments require attention<span id="failureBucketScope" class="font-medium"></span>:
                            <span id="failureBucketDetails" class="font-medium"></span>
                        </p>
                        <button onclick="setStatusFilter('FAILURE')" class="mt-2 px-3 py-1.5 text-xs font-semibold text-white bg-rose-600 rounded-lg hover:bg-rose-700 transition-all">
                            View Failure Bucket
                        </button>
                    </div>
                    <button onclick="dismissFailureAlert()" class="text-rose-400 hover:text-rose-600">
                        <iconify-icon icon="solar:close-circle-linear" width="20"></iconify-icon>
                    </button>
                </div>
            </div>

            <!-- Data Insights (not visible directly in table) -->
            <div id="insightsSection" class="bg-white rounded-xl premium-border premium-shadow overflow-hidden scroll-mt-6">
                <button id="insightsToggle" type="button" onclick="toggleInsightsPanel()" class="w-full p-4 flex items-center justify-between text-left hover:bg-slate-50/80 transition-colors">
                    <span class="flex items-center gap-2">
                        <iconify-icon icon="solar:chart-2-linear" width="20" class="text-indigo-500"></iconify-icon>
                        <span class="text-sm font-bold text-slate-800">Data insights</span>
                        <span class="text-xs text-slate-500 font-normal">(patterns not visible in the table)</span>
                    </span>
                    <iconify-icon id="insightsChevron" icon="solar:alt-arrow-down-linear" width="18" class="text-slate-400 transition-transform"></iconify-icon>
                </button>
                <div id="insightsPanel" class="hidden border-t border-slate-100">
                    <div id="insightsContent" class="p-5 insights-flow flex gap-5 pb-2 lg:flex-wrap lg:grid lg:grid-cols-2 xl:grid-cols-3 lg:overflow-visible">
                        <!-- Filled by renderInsightsPanel() with charts -->
                    </div>
                </div>
            </div>

            <!-- Results Table -->
            <div class="bg-white rounded-xl premium-border premium-shadow overflow-hidden">
                <div class="p-5 border-b border-slate-100 flex items-center justify-between">
                    <div>
                        <h2 class="text-base font-bold text-slate-900">Shipment Results</h2>
                        <p id="resultsSubtitle" class="text-xs text-slate-500 mt-0.5">Track AWBs to see results</p>
                        <p id="lastSyncInfo" class="text-[10px] text-slate-400 mt-1 hidden">
                            <iconify-icon icon="solar:clock-circle-linear" width="10" class="mr-1"></iconify-icon>
                            <span id="lastSyncTime">Never synced</span> • Auto-refresh every hour
                        </p>
                    </div>
                    <div class="flex items-center gap-2">
                        <button id="loadFromServerBtn" onclick="loadShipmentsFromMongo().then(() => {})" class="px-3 py-2 text-xs font-medium text-slate-600 bg-slate-100 rounded-lg hover:bg-slate-200 flex items-center gap-2 disabled:opacity-70 disabled:cursor-not-allowed" title="Load all shipments from MongoDB">
                            <iconify-icon icon="solar:database-linear" width="14"></iconify-icon>
                            Load from server
                        </button>
                        <button onclick="autoRefreshShipments()" id="refreshBtn" class="px-3 py-2 text-xs font-medium text-slate-600 bg-slate-100 rounded-lg hover:bg-slate-200 flex items-center gap-2" title="Refresh all tracked shipments">
                            <iconify-icon icon="solar:refresh-linear" width="14" id="refreshIcon"></iconify-icon>
                            Refresh All
                        </button>
                        <button id="fetchPodBtn" onclick="fetchPodFromApiInBatches()" class="px-3 py-2 text-xs font-medium text-slate-600 bg-slate-100 rounded-lg hover:bg-slate-200 flex items-center gap-2 disabled:opacity-70 disabled:cursor-not-allowed" title="Fetch POD image URLs from tracking API in batches of 20">
                            <iconify-icon icon="solar:gallery-linear" width="14"></iconify-icon>
                            Fetch POD from API
                        </button>
                        <button onclick="exportData()" class="px-3 py-2 text-xs font-medium text-slate-700 bg-white border border-slate-200 rounded-lg hover:bg-slate-50 flex items-center gap-2">
                            <iconify-icon icon="solar:download-linear" width="14"></iconify-icon>
                            Export CSV
                        </button>
                    </div>
                </div>
                
                <div class="overflow-x-auto">
                    <table class="w-full text-left">
                        <thead class="bg-slate-50 border-b border-slate-200">
                            <tr>
                                <th class="py-3 px-4 text-[10px] font-semibold text-slate-500 uppercase tracking-wider">AWB Number</th>
                                <th class="py-3 px-4 text-[10px] font-semibold text-slate-500 uppercase tracking-wider">Customer</th>
                                <th class="py-3 px-4 text-[10px] font-semibold text-slate-500 uppercase tracking-wider">DC / Hub</th>
                                <th class="py-3 px-4 text-[10px] font-semibold text-slate-500 uppercase tracking-wider">Pickup Date</th>
                                <th class="py-3 px-4 text-[10px] font-semibold text-slate-500 uppercase tracking-wider">Status</th>
                                <th class="py-3 px-4 text-[10px] font-semibold text-slate-500 uppercase tracking-wider">EDD</th>
                                <th class="py-3 px-4 text-[10px] font-semibold text-slate-500 uppercase tracking-wider">
                                    <span class="flex items-center gap-1">
                                        Delay
                                        <iconify-icon icon="solar:info-circle-linear" width="12" class="text-slate-400" title="Days past EDD (negative = late)"></iconify-icon>
                                    </span>
                                </th>
                                <th class="py-3 px-4 text-[10px] font-semibold text-slate-500 uppercase tracking-wider">SLA</th>
                                <th class="py-3 px-4 text-[10px] font-semibold text-slate-500 uppercase tracking-wider">Last Update</th>
                                <th class="py-3 px-4 text-[10px] font-semibold text-slate-500 uppercase tracking-wider">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="resultsTable" class="divide-y divide-slate-100 text-sm">
                            <tr>
                                <td colspan="10" class="py-16 text-center">
                                    <div class="flex flex-col items-center">
                                        <iconify-icon icon="solar:magnifer-linear" width="48" class="text-slate-300 mb-3"></iconify-icon>
                                        <p class="text-slate-500 font-medium">No shipments tracked yet</p>
                                        <p class="text-slate-400 text-xs mt-1">Enter an AWB number above to track a shipment</p>
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div id="tableFooter" class="p-4 border-t border-slate-100 bg-slate-50/50 flex flex-wrap justify-between items-center gap-2 text-xs text-slate-500 hidden">
                    <span id="tableStatus">0 shipments</span>
                    <div class="flex items-center gap-3">
                        <div id="pagination" class="flex items-center gap-2">
                            <button onclick="prevPage()" id="prevBtn" class="px-3 py-1.5 rounded border border-slate-200 bg-white hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed" disabled>Previous</button>
                            <span id="pageInfo">Page 1 of 1</span>
                            <button onclick="nextPage()" id="nextBtn" class="px-3 py-1.5 rounded border border-slate-200 bg-white hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed" disabled>Next</button>
                        </div>
                        <div id="serverPagination" class="hidden flex items-center gap-2 border-l border-slate-200 pl-3">
                            <button onclick="prevServerPage()" id="prevServerBtn" class="px-3 py-1.5 rounded border border-slate-200 bg-white hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed">Prev page</button>
                            <span id="serverPageInfo">Server page 1</span>
                            <button onclick="nextServerPage()" id="nextServerBtn" class="px-3 py-1.5 rounded border border-slate-200 bg-white hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed">Next page</button>
                        </div>
                    </div>
                </div>
            </div>

                            </div>
    </main>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="fixed inset-0 bg-slate-900/50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-8 flex flex-col items-center shadow-2xl">
            <iconify-icon icon="solar:refresh-linear" width="40" class="text-blue-600 animate-spin mb-4"></iconify-icon>
            <p class="text-slate-900 font-semibold">Tracking Shipments...</p>
            <p id="loadingStatus" class="text-slate-500 text-sm mt-1">Connecting to API</p>
                </div>
            </div>

    <!-- Toast Notification -->
    <div id="toast" class="fixed bottom-6 right-6 bg-slate-900 text-white px-5 py-3 rounded-lg shadow-xl flex items-center gap-3 transform translate-y-20 opacity-0 transition-all duration-300 z-50">
        <iconify-icon id="toastIcon" icon="solar:check-circle-linear" width="20"></iconify-icon>
        <span id="toastMessage">Success</span>
        </div>

    <script>
        // =====================================================
        // STATE MANAGEMENT
        // =====================================================
        const State = {
            shipments: [],
            filteredShipments: [],
            currentPage: 1,
            pageSize: 20,
            isLoading: false,
            shipmentsLoading: false,
            trackedAwbs: new Set(),
            insightsPanelOpen: false,
            /** Server-side cursor pagination: { pages: [{ shipments, nextAfter }], pageIndex, totalApprox? } */
            serverPagination: null,
        };

        // =====================================================
        // PERSISTENT DATA LAYER (localStorage)
        // =====================================================
        const DataLayer = {
            STORAGE_KEY: 'urbanebolt_shipments',
            STORAGE_CHUNK_PREFIX: 'urbanebolt_shipments_chunk_',
            STORAGE_CHUNK_COUNT_KEY: 'urbanebolt_shipments_chunks',
            AWB_LIST_KEY: 'urbanebolt_tracked_awbs',
            LAST_SYNC_KEY: 'urbanebolt_last_sync',
            SYNC_INTERVAL: 60 * 60 * 1000, // 1 hour in milliseconds
            CACHE_CHUNK_SIZE: 800, // items per chunk to stay under localStorage ~5MB total

            // Load cached shipments from localStorage (supports single key or chunked)
            loadCache() {
                try {
                    const chunkCount = localStorage.getItem(this.STORAGE_CHUNK_COUNT_KEY);
                    if (chunkCount != null && chunkCount !== '') {
                        const n = Math.max(0, parseInt(chunkCount, 10));
                        if (n > 0) {
                            const out = [];
                            for (let i = 0; i < n; i++) {
                                const key = this.STORAGE_CHUNK_PREFIX + i;
                                const raw = localStorage.getItem(key);
                                if (raw) {
                                    const part = JSON.parse(raw);
                                    if (Array.isArray(part)) out.push(...part);
                                }
                            }
                            return out;
                        }
                    }
                    const cached = localStorage.getItem(this.STORAGE_KEY);
                    return cached ? JSON.parse(cached) : [];
                } catch (e) {
                    console.warn('[DataLayer] Failed to load cache:', e);
                    return [];
                }
            },

            // Save shipments to localStorage; use chunked storage when single key would exceed quota
            saveCache(shipments) {
                const list = Array.isArray(shipments) ? shipments : [];
                let useChunked = list.length > this.CACHE_CHUNK_SIZE;
                if (!useChunked) {
                    try {
                        const single = JSON.stringify(list);
                        if (single.length < 4 * 1024 * 1024) {
                            try {
                                localStorage.setItem(this.STORAGE_KEY, single);
                                this._clearChunkedCache();
                                return;
                            } catch (e) {
                                if (e && (e.name === 'QuotaExceededError' || e.code === 22)) useChunked = true;
                                else throw e;
                            }
                        } else useChunked = true;
                    } catch (e) {
                        if (e && (e.name === 'QuotaExceededError' || e.code === 22)) useChunked = true;
                        else {
                            console.warn('[DataLayer] Failed to save cache:', e);
                            return;
                        }
                    }
                }
                if (useChunked) {
                    try {
                        this._clearChunkedCache();
                        const size = this.CACHE_CHUNK_SIZE;
                        let chunks = 0;
                        for (let i = 0; i < list.length; i += size) {
                            const chunk = list.slice(i, i + size);
                            localStorage.setItem(this.STORAGE_CHUNK_PREFIX + chunks, JSON.stringify(chunk));
                            chunks++;
                        }
                        localStorage.setItem(this.STORAGE_CHUNK_COUNT_KEY, String(chunks));
                        localStorage.removeItem(this.STORAGE_KEY);
                    } catch (e) {
                        console.warn('[DataLayer] Failed to save cache (chunked):', e);
                    }
                }
            },

            _clearChunkedCache() {
                try {
                    const n = localStorage.getItem(this.STORAGE_CHUNK_COUNT_KEY);
                    if (n != null && n !== '') {
                        const max = Math.max(0, parseInt(n, 10));
                        for (let i = 0; i < max; i++) localStorage.removeItem(this.STORAGE_CHUNK_PREFIX + i);
                    }
                    localStorage.removeItem(this.STORAGE_CHUNK_COUNT_KEY);
                } catch (_) {}
            },

            // Get list of tracked AWBs
            getTrackedAwbs() {
                try {
                    const awbs = localStorage.getItem(this.AWB_LIST_KEY);
                    return awbs ? JSON.parse(awbs) : [];
                } catch (e) {
                    return [];
                }
            },

            // Save tracked AWB list
            saveTrackedAwbs(awbs) {
                try {
                    localStorage.setItem(this.AWB_LIST_KEY, JSON.stringify([...awbs]));
                } catch (e) {
                    console.warn('[DataLayer] Failed to save AWB list:', e);
                }
            },

            // Add AWB to tracked list
            addAwb(awb) {
                const awbs = new Set(this.getTrackedAwbs());
                awbs.add(String(awb));
                this.saveTrackedAwbs(awbs);
            },

            // Get last sync timestamp
            getLastSync() {
                return parseInt(localStorage.getItem(this.LAST_SYNC_KEY) || '0');
            },

            // Update last sync timestamp
            updateLastSync() {
                localStorage.setItem(this.LAST_SYNC_KEY, Date.now().toString());
            },

            // Check if sync is due
            isSyncDue() {
                const lastSync = this.getLastSync();
                return Date.now() - lastSync >= this.SYNC_INTERVAL;
            },

            // Clear all data
            clearAll() {
                localStorage.removeItem(this.STORAGE_KEY);
                this._clearChunkedCache();
                localStorage.removeItem(this.AWB_LIST_KEY);
                localStorage.removeItem(this.LAST_SYNC_KEY);
            }
        };

        // =====================================================
        // API CONFIGURATION FALLBACK
        // =====================================================
        // Ensure API is configured (fallback in case config.js is missing)
        (function ensureApiConfigured() {
            if (typeof API !== 'undefined' && API.getConfig) {
                const config = API.getConfig();
                if (!config.baseUrl) {
                    const isLocal = /^(localhost|127\.0\.0\.1)$/.test(window.location.hostname);
                    const base = isLocal ? window.location.origin : 'https://api.urbanebolt.in';
                    console.warn('[Fallback] API not configured, using', base);
                    API.configure({ baseUrl: base, maxBatchSize: 20 });
                }
            }
        })();

        // =====================================================
        // INITIALIZATION
        // =====================================================
        document.addEventListener('DOMContentLoaded', () => {
            // Ensure API is configured (check again after DOMContentLoaded)
            if (typeof API !== 'undefined' && API.getConfig) {
                const config = API.getConfig();
                if (!config.baseUrl) {
                    const isLocal = /^(localhost|127\.0\.0\.1)$/.test(window.location.hostname);
                    API.configure({
                        baseUrl: isLocal ? window.location.origin : 'https://api.urbanebolt.in',
                        maxBatchSize: 20,
                    });
                }
            }

            // Set current date
            document.getElementById('currentDate').textContent = new Date().toLocaleDateString('en-IN', { 
                weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
            });
            // Leave date filter empty by default so all shipments show (Excel data is often historical)
            document.getElementById('dateFilter').value = '';

            // Keyboard shortcuts
            document.getElementById('awbSearchInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') trackSingleAWB();
            });
            document.getElementById('bulkAwbInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') trackBulkAWB();
            });

            // Check API connection
            checkApiConnection();

            // Show cache first for instant display, then load all shipments from MongoDB so full list is always shown
            loadCachedData();
            loadDashboardSummary();
            loadShipmentsFromMongo().then(() => {});

            // Start auto-refresh (after a short delay to let API initialize)
            setTimeout(() => {
                // Do initial sync if due
                if (DataLayer.isSyncDue() && DataLayer.getTrackedAwbs().length > 0) {
                    console.log('[AutoSync] Initial sync triggered');
                    autoRefreshShipments();
                }
            }, 1000);

            // Set up hourly auto-refresh for manually tracked AWBs
            setInterval(() => {
                if (DataLayer.getTrackedAwbs().length > 0) {
                    console.log('[AutoSync] Hourly refresh triggered');
                    autoRefreshShipments();
                }
            }, DataLayer.SYNC_INTERVAL);

            // Also refresh when tab becomes visible (if sync is due)
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden && DataLayer.isSyncDue() && DataLayer.getTrackedAwbs().length > 0) {
                    console.log('[AutoSync] Visibility refresh triggered');
                    autoRefreshShipments();
                }
            });

            // Update "last synced X ago" display every minute
            setInterval(updateLastSyncDisplay, 60000);
        });

        // =====================================================
        // LOAD CACHED DATA (localStorage fallback)
        // =====================================================
        function loadCachedData() {
            const cachedShipments = DataLayer.loadCache();
            const trackedAwbs = DataLayer.getTrackedAwbs();

            if (cachedShipments.length > 0) {
                State.shipments = cachedShipments;
                State.trackedAwbs = new Set(trackedAwbs);
                
                sortShipmentsByDate();
                updateFilterDropdowns();
                applyFiltersAndRender();
                updateLastSyncDisplay();
                
                const lastSync = DataLayer.getLastSync();
                if (lastSync > 0) {
                    const ago = formatTimeAgo(lastSync);
                    showToast(`Loaded ${cachedShipments.length} shipments from cache`, 'info');
                }
            }
        }

        // =====================================================
        // TABLE LOADING STATE (spinner + message in table body)
        // =====================================================
        function showTableLoading(message) {
            const tbody = document.getElementById('resultsTable');
            const footer = document.getElementById('tableFooter');
            if (!tbody) return;
            tbody.innerHTML = `
                <tr>
                    <td colspan="10" class="py-16 text-center">
                        <div class="flex flex-col items-center">
                            <iconify-icon icon="solar:refresh-linear" width="40" class="text-blue-500 animate-spin mb-3"></iconify-icon>
                            <p class="text-slate-600 font-medium">${message || 'Loading...'}</p>
                        </div>
                    </td>
                </tr>
            `;
            if (footer) footer.classList.add('hidden');
        }

        // =====================================================
        // LOAD SHIPMENTS FROM MONGODB (server-side pagination: one page per request, Vercel-safe)
        // =====================================================
        const SERVER_PAGE_SIZE = 100;
        async function loadShipmentsFromMongo() {
            if (typeof API === 'undefined' || !API.getShipmentsPage) return false;
            const config = API.getConfig && API.getConfig();
            if (!config || !config.baseUrl) return false;
            if (State.shipmentsLoading) return false;

            const loadBtn = document.getElementById('loadFromServerBtn');
            State.shipmentsLoading = true;
            if (loadBtn) {
                loadBtn.disabled = true;
                loadBtn.innerHTML = '<iconify-icon icon="solar:refresh-linear" width="14" class="animate-spin"></iconify-icon> Loading...';
            }
            showTableLoading('Loading first page...');

            try {
                const data = await API.getShipmentsPage({ limit: SERVER_PAGE_SIZE, includeTotal: true });
                const list = (data.shipments || []).map(mongoDocToShipment).filter(s => s && s.awb);
                State.shipments = list;
                State.filteredShipments = list;
                State.serverPagination = {
                    pages: [{ shipments: list, nextAfter: data.nextAfter || null }],
                    pageIndex: 0,
                    totalApprox: data.total != null ? data.total : undefined,
                };
                State.currentPage = 1;
                State.trackedAwbs = new Set(list.map(s => s.awb));
                sortShipmentsByDate();
                try {
                    DataLayer.updateLastSync();
                } catch (e) {}
                updateFilterDropdowns();
                clearFilters();
                applyFiltersAndRender();
                updateLastSyncDisplay();
                await loadDashboardSummary();
                if (list.length > 0) {
                    showToast(`Loaded page 1 (${list.length} shipments). Use Next page for more.`, 'success');
                }
                return true;
            } catch (e) {
                console.warn('[Mongo] Load failed:', e.message || e);
                showTableLoading(State.shipments.length ? 'Using cached data. Load failed: ' + (e.message || e) : 'Load failed. Try again or check connection.');
                if (e.status === 404 || e.status === 405 || (e.message && (e.message.includes('404') || e.message.includes('405')))) {
                    showToast('Dashboard API not available. Check backend and open from same origin.', 'error');
                }
                if (State.shipments.length > 0) applyFiltersAndRender();
                return false;
            } finally {
                State.shipmentsLoading = false;
                if (loadBtn) {
                    loadBtn.disabled = false;
                    loadBtn.innerHTML = '<iconify-icon icon="solar:database-linear" width="14"></iconify-icon> Load from server';
                }
            }
        }

        async function nextServerPage() {
            if (!State.serverPagination || !API.getShipmentsPage) return;
            const cur = State.serverPagination.pages[State.serverPagination.pageIndex];
            if (!cur || !cur.nextAfter) return;
            const loadBtn = document.getElementById('nextServerBtn');
            if (loadBtn) loadBtn.disabled = true;
            showTableLoading('Loading next page...');
            try {
                const data = await API.getShipmentsPage({ limit: SERVER_PAGE_SIZE, after: cur.nextAfter });
                const list = (data.shipments || []).map(mongoDocToShipment).filter(s => s && s.awb);
                State.serverPagination.pages.push({ shipments: list, nextAfter: data.nextAfter || null });
                State.serverPagination.pageIndex = State.serverPagination.pages.length - 1;
                State.shipments = list;
                State.filteredShipments = list;
                State.currentPage = 1;
                applyFiltersAndRender();
                updateLastSyncDisplay();
                if (list.length > 0) showToast(`Loaded page ${State.serverPagination.pageIndex + 1} (${list.length} rows)`, 'success');
            } catch (e) {
                console.warn('[Mongo] Next page failed:', e.message || e);
                showToast('Failed to load next page: ' + (e.message || e), 'error');
            } finally {
                if (loadBtn) loadBtn.disabled = false;
            }
        }

        function prevServerPage() {
            if (!State.serverPagination || State.serverPagination.pageIndex <= 0) return;
            State.serverPagination.pageIndex--;
            const page = State.serverPagination.pages[State.serverPagination.pageIndex];
            State.shipments = page.shipments;
            State.filteredShipments = page.shipments;
            State.currentPage = 1;
            applyFiltersAndRender();
        }

        /**
         * Fetch POD image URLs from the tracking API in batches of 20 and merge into State.shipments.
         */
        async function fetchPodFromApiInBatches() {
            const btn = document.getElementById('fetchPodBtn');
            if (!State.shipments || State.shipments.length === 0) {
                if (btn) btn.disabled = false;
                return;
            }
            if (typeof API === 'undefined' || !API.tracking || !API.tracking.getPodUrlsFromTracking) {
                alert('Tracking API not configured or getPodUrlsFromTracking not available.');
                return;
            }
            const awbs = State.shipments.map(s => s.awb).filter(Boolean);
            if (awbs.length === 0) return;
            if (btn) {
                btn.disabled = true;
                btn.innerHTML = '<iconify-icon icon="solar:refresh-linear" width="14" class="animate-spin"></iconify-icon> Fetching POD…';
            }
            try {
                const podMap = await API.tracking.getPodUrlsFromTracking(awbs);
                let updated = 0;
                State.shipments.forEach(s => {
                    if (s.awb && podMap[s.awb]) {
                        s.delPod = podMap[s.awb];
                        updated++;
                    }
                });
                DataLayer.saveCache(State.shipments);
                applyFiltersAndRender();
                if (btn) btn.innerHTML = '<iconify-icon icon="solar:gallery-linear" width="14"></iconify-icon> Fetch POD from API';
            } catch (e) {
                console.error('[Dashboard] Fetch POD failed:', e);
                if (btn) btn.innerHTML = '<iconify-icon icon="solar:gallery-linear" width="14"></iconify-icon> Fetch POD from API';
            } finally {
                if (btn) btn.disabled = false;
            }
        }

        // =====================================================
        // LOAD DASHBOARD SUMMARY FROM BACKEND (KPIs from Mongo aggregation)
        // =====================================================
        async function loadDashboardSummary() {
            if (typeof API === 'undefined' || !API.getDashboardSummary) return false;
            const config = API.getConfig && API.getConfig();
            if (!config || !config.baseUrl) return false;
            const getKpiEl = (id) => document.getElementById(id);
            try {
                if (getKpiEl('kpi-dsr')) getKpiEl('kpi-dsr').textContent = '...';
                const s = await API.getDashboardSummary();
                const totalShipments = Number(s.totalShipments) || 0;
                const deliveredCount = Number(s.deliveredCount) ?? 0;
                const rtoCount = Number(s.rtoCount) ?? 0;
                const inTransitCount = Number(s.inTransitCount) ?? 0;
                const slaPercentage = Number(s.slaPercentage) || 0;
                const breachCount = Number(s.breachCount) || 0;
                const openBreachCount = Number(s.openBreachCount) || 0;
                const revenueAtRisk = Number(s.revenueAtRisk) || 0;

                if (getKpiEl('kpi-total')) getKpiEl('kpi-total').textContent = totalShipments.toLocaleString();
                if (getKpiEl('kpi-delivered')) getKpiEl('kpi-delivered').textContent = deliveredCount.toLocaleString();
                if (getKpiEl('kpi-intransit')) getKpiEl('kpi-intransit').textContent = inTransitCount.toLocaleString();
                if (getKpiEl('kpi-exceptions')) getKpiEl('kpi-exceptions').textContent = rtoCount.toLocaleString();
                if (getKpiEl('kpi-dsr')) getKpiEl('kpi-dsr').textContent = slaPercentage + '%';
                if (getKpiEl('kpi-delayed')) getKpiEl('kpi-delayed').textContent = openBreachCount.toLocaleString();
                if (getKpiEl('kpi-breach')) getKpiEl('kpi-breach').textContent = breachCount.toLocaleString();
                if (getKpiEl('kpi-cod')) getKpiEl('kpi-cod').textContent = '₹' + revenueAtRisk.toLocaleString('en-IN');
                if (getKpiEl('kpi-avgdelay')) getKpiEl('kpi-avgdelay').textContent = '-- days';
                const badge = getKpiEl('exceptionBadge');
                if (badge) {
                    if (rtoCount > 0) { badge.textContent = rtoCount; badge.classList.remove('hidden'); }
                    else { badge.classList.add('hidden'); }
                }
                if (typeof Chart !== 'undefined' && getKpiEl('summaryChartCanvas')) {
                    const other = Math.max(0, totalShipments - openBreachCount - breachCount);
                    const legendEl = getKpiEl('summaryChartLegend');
                    if (legendEl) legendEl.textContent = totalShipments + ' total • ' + slaPercentage + '% on-time • ₹' + revenueAtRisk.toLocaleString('en-IN') + ' at risk';
                    if (window._summaryChart) window._summaryChart.destroy();
                    window._summaryChart = new Chart(getKpiEl('summaryChartCanvas'), {
                        type: 'doughnut',
                        data: {
                            labels: ['Open breach', 'Breach (late)', 'On time / In progress'],
                            datasets: [{ data: [openBreachCount, breachCount, other], backgroundColor: ['#f59e0b', '#ef4444', '#10b981'] }],
                        },
                        options: { responsive: true, maintainAspectRatio: true, plugins: { legend: { position: 'bottom' } } },
                    });
                }
                return true;
            } catch (e) {
                console.warn('[Dashboard] Summary load failed:', e.message || e);
                return false;
            }
        }

        // Sort State.shipments by most recent date
        function sortShipmentsByDate() {
            State.shipments.sort((a, b) => {
                const dateA = parseShipmentDate(a.lastUpdate);
                const dateB = parseShipmentDate(b.lastUpdate);
                return dateB - dateA; // Descending (most recent first)
            });
        }

        // Update last sync display in UI
        function updateLastSyncDisplay() {
            const lastSyncInfo = document.getElementById('lastSyncInfo');
            const lastSyncTime = document.getElementById('lastSyncTime');
            const lastSync = DataLayer.getLastSync();
            
            if (State.shipments.length > 0) {
                lastSyncInfo.classList.remove('hidden');
                if (lastSync > 0) {
                    lastSyncTime.textContent = `Last synced ${formatTimeAgo(lastSync)}`;
                } else {
                    lastSyncTime.textContent = 'Not synced yet';
                }
            } else {
                lastSyncInfo.classList.add('hidden');
            }
        }

        // =====================================================
        // AUTO REFRESH SHIPMENTS (Hourly)
        // =====================================================
        async function autoRefreshShipments() {
            const trackedAwbs = DataLayer.getTrackedAwbs();
            
            if (trackedAwbs.length === 0) {
                console.log('[AutoSync] No AWBs to refresh');
                return;
            }

            // Don't interrupt if user is manually loading
            if (State.isLoading) {
                console.log('[AutoSync] Skipping - manual load in progress');
                return;
            }

            console.log(`[AutoSync] Refreshing ${trackedAwbs.length} shipments...`);
            // Run in background without full-screen overlay
            try {
                // Process in batches of 20 (API limit)
                const batchSize = 20;
                let successCount = 0;
                let failCount = 0;

                for (let i = 0; i < trackedAwbs.length; i += batchSize) {
                    const batch = trackedAwbs.slice(i, i + batchSize);
                    
                    // Check rate limit before each batch
                    const apiStatus = API.getStatus();
                    if (apiStatus.requestsLastMinute >= 50) {
                        console.log('[AutoSync] Approaching rate limit, pausing...');
                        await new Promise(r => setTimeout(r, 60000)); // Wait 1 minute
                    }

                    const results = await API.tracking.getMultiple(batch);
                    
                    results.forEach(result => {
                        if (result.success && result.data) {
                            const shipment = normalizeShipmentData(result.data);
                            const existingIndex = State.shipments.findIndex(s => s.awb === shipment.awb);
                            if (existingIndex >= 0) {
                                State.shipments[existingIndex] = shipment;
                            } else {
                                State.shipments.unshift(shipment);
                            }
                            successCount++;
                        } else {
                            failCount++;
                        }
                    });

                    // Small delay between batches
                    if (i + batchSize < trackedAwbs.length) {
                        await new Promise(r => setTimeout(r, 500));
                    }
                }

                // Sort by most recent first
                sortShipmentsByDate();

                // Save updated data to cache
                DataLayer.saveCache(State.shipments);
                DataLayer.updateLastSync();

                // Update filter dropdowns with new data
                updateFilterDropdowns();
                applyFiltersAndRender();
                updateRateLimitStatus();

                showToast(`Synced ${successCount} shipments`, 'success');
                updateLastSyncDisplay();

            } catch (error) {
                console.error('[AutoSync] Error:', error);
                showToast('Auto-refresh failed. Will retry later.', 'error');
            }
        }

        // Format time ago helper
        function formatTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }

        // =====================================================
        // API CONNECTION & RATE LIMIT MONITORING
        // =====================================================
        function checkApiConnection() {
            const status = document.getElementById('connectionStatus');
            const rateLimit = document.getElementById('rateLimitStatus');
            
            try {
                if (typeof API !== 'undefined') {
                    status.innerHTML = '<span class="w-2 h-2 rounded-full bg-emerald-500"></span><span>API Ready</span>';
                    status.className = 'flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-emerald-50 text-emerald-700';
                    rateLimit.classList.remove('hidden');
                    updateRateLimitStatus();
                } else {
                    status.innerHTML = '<span class="w-2 h-2 rounded-full bg-amber-500"></span><span>Loading API...</span>';
                    status.className = 'flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-amber-50 text-amber-700';
                }
            } catch (e) {
                status.innerHTML = '<span class="w-2 h-2 rounded-full bg-rose-500"></span><span>API Error</span>';
                status.className = 'flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-rose-50 text-rose-700';
            }
        }

        function updateRateLimitStatus() {
            const rateLimit = document.getElementById('rateLimitStatus');
            try {
                const apiStatus = API.getStatus();
                const used = apiStatus.requestsLastMinute || 0;
                const max = API.MAX_REQUESTS_PER_MINUTE || 60;
                const percentage = (used / max) * 100;
                
                rateLimit.innerHTML = `<iconify-icon icon="solar:shield-check-linear" width="12"></iconify-icon><span>${used}/${max} req/min</span>`;
                
                if (percentage >= 80) {
                    rateLimit.className = 'flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-rose-50 text-rose-600';
                } else if (percentage >= 50) {
                    rateLimit.className = 'flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-amber-50 text-amber-600';
            } else {
                    rateLimit.className = 'flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-blue-50 text-blue-600';
                }

                // Show circuit breaker status if open
                if (apiStatus.circuitOpen) {
                    rateLimit.innerHTML = '<iconify-icon icon="solar:shield-warning-linear" width="12"></iconify-icon><span>Rate Limited - Wait 30s</span>';
                    rateLimit.className = 'flex items-center gap-1.5 text-xs px-2 py-1 rounded-full bg-rose-50 text-rose-600';
                }
            } catch (e) {
                console.warn('Could not get API status:', e);
            }
        }

        // Update rate limit status every 5 seconds
        setInterval(updateRateLimitStatus, 5000);

        // =====================================================
        // LOADING STATE
        // =====================================================
        function setLoading(loading, message = 'Connecting to API') {
            State.isLoading = loading;
            const overlay = document.getElementById('loadingOverlay');
            const loadingStatus = document.getElementById('loadingStatus');
            
            if (loading) {
                overlay.classList.remove('hidden');
                loadingStatus.textContent = message;
            } else {
                overlay.classList.add('hidden');
            }
        }

        // =====================================================
        // TOAST NOTIFICATIONS
        // =====================================================
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const icon = document.getElementById('toastIcon');
            const msg = document.getElementById('toastMessage');

            msg.textContent = message;
            
            if (type === 'success') {
                toast.className = 'fixed bottom-6 right-6 bg-emerald-600 text-white px-5 py-3 rounded-lg shadow-xl flex items-center gap-3 transition-all duration-300 z-50';
                icon.setAttribute('icon', 'solar:check-circle-linear');
            } else if (type === 'error') {
                toast.className = 'fixed bottom-6 right-6 bg-rose-600 text-white px-5 py-3 rounded-lg shadow-xl flex items-center gap-3 transition-all duration-300 z-50';
                icon.setAttribute('icon', 'solar:danger-triangle-linear');
            } else {
                toast.className = 'fixed bottom-6 right-6 bg-slate-900 text-white px-5 py-3 rounded-lg shadow-xl flex items-center gap-3 transition-all duration-300 z-50';
                icon.setAttribute('icon', 'solar:info-circle-linear');
            }

            toast.style.transform = 'translateY(0)';
            toast.style.opacity = '1';

            setTimeout(() => {
                toast.style.transform = 'translateY(20px)';
                toast.style.opacity = '0';
            }, 3000);
        }

        // =====================================================
        // TRACK SINGLE AWB
        // =====================================================
        async function trackSingleAWB() {
            const input = document.getElementById('awbSearchInput');
            const awb = input.value.trim();

            if (!awb) {
                showToast('Please enter an AWB number', 'error');
                input.focus();
                return;
            }

            // Validate AWB format (alphanumeric)
            if (!/^[a-zA-Z0-9]+$/.test(awb)) {
                showToast('Invalid AWB format. Use only letters and numbers.', 'error');
                return;
            }

            setLoading(true, `Tracking AWB: ${awb}`);

            try {
                const data = await API.tracking.getByAwb(awb);
                
                if (data) {
                    const shipment = normalizeShipmentData(data);
                    
                    // Check if already tracked, update if so
                    const existingIndex = State.shipments.findIndex(s => s.awb === shipment.awb);
                    if (existingIndex >= 0) {
                        State.shipments[existingIndex] = shipment;
                    } else {
                        State.shipments.unshift(shipment);
                    }
                    State.trackedAwbs.add(shipment.awb);
                    
                    // Persist to localStorage
                    DataLayer.addAwb(shipment.awb);
                    DataLayer.saveCache(State.shipments);
                    DataLayer.updateLastSync();
                    
                    updateFilterDropdowns();
                    applyFiltersAndRender();
                    updateLastSyncDisplay();
                    showToast(`AWB ${awb} tracked`, 'success');
                    input.value = '';
                } else {
                    showToast(`No shipment found for AWB: ${awb}`, 'error');
                }
            } catch (error) {
                console.error('[Track] Error:', error);
                handleApiError(error, awb);
            } finally {
                setLoading(false);
                updateRateLimitStatus();
            }
        }

        function handleApiError(error, awb = '') {
            const msg = error.message || 'Unknown error';
            
            // Provide user-friendly error messages
            if (msg.includes('Circuit breaker')) {
                showToast('Too many requests. Please wait 30 seconds.', 'error');
            } else if (msg.includes('timeout')) {
                showToast('Request timed out. The API is slow or unavailable.', 'error');
            } else if (msg.includes('Failed to fetch') || msg.includes('NetworkError')) {
                showToast('Network error. Check your connection or API may be down.', 'error');
            } else if (msg.includes('HTTP 429')) {
                showToast('Rate limit exceeded on server. Wait and try again.', 'error');
            } else if (msg.includes('HTTP 401') || msg.includes('HTTP 403')) {
                showToast('Authentication required or access denied.', 'error');
            } else if (msg.includes('HTTP 404')) {
                showToast(`AWB ${awb} not found in system.`, 'error');
            } else if (msg.includes('HTTP 5')) {
                showToast('Server error. The API is experiencing issues.', 'error');
                } else {
                showToast(msg, 'error');
            }
        }

        // =====================================================
        // TRACK BULK AWBs
        // =====================================================
        async function trackBulkAWB() {
            const input = document.getElementById('bulkAwbInput');
            const rawInput = input.value.trim();

            if (!rawInput) {
                showToast('Please enter AWB numbers (comma separated)', 'error');
                input.focus();
                return;
            }

            // Parse AWBs - support comma, space, newline separation
            const awbs = rawInput
                .split(/[,\s\n]+/)
                .map(a => a.trim())
                .filter(a => a && /^[a-zA-Z0-9]+$/.test(a));

            if (awbs.length === 0) {
                showToast('No valid AWB numbers found', 'error');
                return;
            }

            if (awbs.length > 20) {
                showToast(`Maximum 20 AWBs allowed. You entered ${awbs.length}.`, 'error');
                return;
            }

            setLoading(true, `Tracking ${awbs.length} AWBs (batch mode)`);

            try {
                const results = await API.tracking.getMultiple(awbs);
                
                let successCount = 0;
                let failCount = 0;

                results.forEach(result => {
                    if (result.success && result.data) {
                        const shipment = normalizeShipmentData(result.data);
                        const existingIndex = State.shipments.findIndex(s => s.awb === shipment.awb);
                        if (existingIndex >= 0) {
                            State.shipments[existingIndex] = shipment;
                        } else {
                            State.shipments.unshift(shipment);
                        }
                        State.trackedAwbs.add(shipment.awb);
                        DataLayer.addAwb(shipment.awb); // Persist AWB
                        successCount++;
                    } else {
                        failCount++;
                    }
                });

                // Persist all data to localStorage
                DataLayer.saveCache(State.shipments);
                DataLayer.updateLastSync();

                updateFilterDropdowns();
                applyFiltersAndRender();
                updateLastSyncDisplay();
                
                if (failCount > 0) {
                    showToast(`${successCount} tracked, ${failCount} failed`, 'info');
                } else {
                    showToast(`${successCount} AWBs tracked`, 'success');
                }
                
                input.value = '';
            } catch (error) {
                console.error('[Bulk Track] Error:', error);
                handleApiError(error);
            } finally {
                setLoading(false);
                updateRateLimitStatus();
            }
        }

        // =====================================================
        // EXCEL FILE UPLOAD & PARSING
        // =====================================================
        const ExcelUpload = {
            workbook: null,
            sheetData: [],
            rowObjects: [], // [{Header: value, ...}]
            columns: [],
            selectedColumn: null,
            extractedAwbs: [],
            hasHeaders: true,
            awbHeaderKey: null,
        };

        function onExcelModeToggle() {
            // In full-data mode, we still need AWB column, but UX is "import rows" vs "track AWBs"
            renderExcelPreview();
        }

        async function handleUploadToMongo(event) {
            const file = event.target.files[0];
            event.target.value = '';
            if (!file) return;
            const fileName = file.name;
            const fileExt = fileName.split('.').pop().toLowerCase();
            if (!['xlsx', 'xls', 'csv'].includes(fileExt)) {
                showToast('Please select an Excel (.xlsx, .xls) or CSV file', 'error');
                return;
            }
            const btn = document.getElementById('mongoUploadBtn');
            if (btn) btn.disabled = true;
            showToast(`Uploading ${fileName} to MongoDB...`, 'info');
            try {
                const res = await API.uploadExcel(file);
                showToast(`Uploaded: ${res.insertedCount} new, ${res.modifiedCount} updated (${res.totalRows} rows)`, 'success');
                await loadShipmentsFromMongo();
                await loadDashboardSummary();
            } catch (e) {
                if (e.status === 404 || e.status === 405) {
                    showToast('Upload API not available. Start the backend (npm run dev:api in backend/) and open this page from the same URL (e.g. http://localhost:3000).', 'error');
                } else {
                    const msg = e.message || String(e);
                    const detail = e.detail ? ' — ' + e.detail : '';
                    showToast('Upload failed: ' + msg + detail, 'error');
                }
            }
            if (btn) btn.disabled = false;
        }

        function handleExcelUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const fileName = file.name;
            const fileExt = fileName.split('.').pop().toLowerCase();
            
            if (!['xlsx', 'xls', 'csv'].includes(fileExt)) {
                showToast('Please upload an Excel (.xlsx, .xls) or CSV file', 'error');
                return;
            }

            showToast(`Reading ${fileName}...`, 'info');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    ExcelUpload.workbook = XLSX.read(data, { type: 'array' });
                    
                    // Get first sheet
                    const firstSheet = ExcelUpload.workbook.SheetNames[0];
                    const worksheet = ExcelUpload.workbook.Sheets[firstSheet];
                    
                    // Convert to JSON (both: array-of-arrays and object-rows)
                    ExcelUpload.sheetData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                    ExcelUpload.rowObjects = XLSX.utils.sheet_to_json(worksheet, { defval: '', raw: false });
                    
                    if (ExcelUpload.sheetData.length === 0) {
                        showToast('Excel file is empty', 'error');
                        return;
                    }
                    
                    // Get columns from first row (headers)
                    ExcelUpload.columns = ExcelUpload.sheetData[0] || [];
                    ExcelUpload.hasHeaders = ExcelUpload.columns.some(c => String(c || '').trim().length > 0);
                    
                    // Show panel
                    document.getElementById('excelFileName').textContent = fileName;
                    renderExcelColumns();
                    document.getElementById('excelUploadPanel').classList.remove('hidden');
                    
                    // Auto-select AWB column if found
                    autoSelectAwbColumn();
                    renderExcelPreview();
                    
                } catch (error) {
                    console.error('[Excel] Parse error:', error);
                    showToast('Failed to parse Excel file', 'error');
                }
            };
            reader.readAsArrayBuffer(file);
            
            // Reset file input
            event.target.value = '';
        }

        function renderExcelColumns() {
            const container = document.getElementById('excelColumns');
            container.innerHTML = '';
            
            ExcelUpload.columns.forEach((col, index) => {
                const colName = col || `Column ${index + 1}`;
                const btn = document.createElement('button');
                btn.className = 'px-3 py-1.5 text-xs font-medium rounded-lg border transition-all ' +
                    (ExcelUpload.selectedColumn === index 
                        ? 'bg-emerald-100 border-emerald-400 text-emerald-800' 
                        : 'bg-white border-slate-200 text-slate-600 hover:border-slate-300');
                btn.textContent = colName;
                btn.onclick = () => selectExcelColumn(index);
                container.appendChild(btn);
            });
            
            // If no headers, show column indices
            if (ExcelUpload.columns.length === 0 && ExcelUpload.sheetData.length > 0) {
                const numCols = ExcelUpload.sheetData[0]?.length || 1;
                for (let i = 0; i < numCols; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'px-3 py-1.5 text-xs font-medium rounded-lg border bg-white border-slate-200 text-slate-600 hover:border-slate-300 transition-all';
                    btn.textContent = `Column ${String.fromCharCode(65 + i)}`;
                    btn.onclick = () => selectExcelColumn(i);
                    container.appendChild(btn);
                }
            }
        }

        function autoSelectAwbColumn() {
            // Try to find AWB column by name
            const awbKeywords = ['awb', 'awb_number', 'awbnumber', 'tracking', 'tracking_number', 'shipment', 'waybill', 'consignment'];
            
            for (let i = 0; i < ExcelUpload.columns.length; i++) {
                const colName = String(ExcelUpload.columns[i] || '').toLowerCase().replace(/[^a-z0-9]/g, '');
                if (awbKeywords.some(kw => colName.includes(kw))) {
                    selectExcelColumn(i);
                    return;
                }
            }
            
            // Default to first column
            if (ExcelUpload.columns.length > 0 || ExcelUpload.sheetData.length > 0) {
                selectExcelColumn(0);
            }
        }

        function selectExcelColumn(index) {
            ExcelUpload.selectedColumn = index;
            // Remember header key for AWB in rowObjects (for full-data mode)
            ExcelUpload.awbHeaderKey = null;
            if (ExcelUpload.hasHeaders && ExcelUpload.columns[index]) {
                ExcelUpload.awbHeaderKey = ExcelUpload.columns[index];
            }
            
            // Extract AWBs from selected column
            const awbSet = new Set();
            const startRow = ExcelUpload.hasHeaders ? 1 : 0; // Skip header if exists
            
            for (let i = startRow; i < ExcelUpload.sheetData.length; i++) {
                const row = ExcelUpload.sheetData[i];
                if (row && row[index] !== undefined && row[index] !== null && row[index] !== '') {
                    const awb = String(row[index]).trim();
                    // Validate: only alphanumeric, reasonable length
                    if (/^[a-zA-Z0-9]+$/.test(awb) && awb.length >= 5 && awb.length <= 30) {
                        awbSet.add(awb);
                    }
                }
            }
            ExcelUpload.extractedAwbs = Array.from(awbSet);
            
            // Update UI
            renderExcelColumns(); // Re-render to update selection
            renderExcelPreview();
        }

        function renderExcelPreview() {
            const previewContainer = document.getElementById('excelAwbPreview');
            const countEl = document.getElementById('excelAwbCount');
            const trackCountEl = document.getElementById('excelTrackCount');
            const warningEl = document.getElementById('excelLargeFileWarning');
            const etaEl = document.getElementById('excelEtaEstimate');
            const fullDataMode = document.getElementById('excelFullDataMode')?.checked;
            
            const awbs = ExcelUpload.extractedAwbs;
            const rowsCount = ExcelUpload.rowObjects?.length ? ExcelUpload.rowObjects.length : Math.max(0, ExcelUpload.sheetData.length - 1);
            countEl.textContent = fullDataMode
                ? `${rowsCount.toLocaleString()} rows loaded • ${awbs.length.toLocaleString()} unique AWBs`
                : `${awbs.length.toLocaleString()} AWBs found`;
            trackCountEl.textContent = fullDataMode ? `${rowsCount.toLocaleString()} rows` : `${awbs.length.toLocaleString()} AWBs`;
            
            // Show first 10 as preview
            const preview = awbs.slice(0, 10);
            previewContainer.innerHTML = preview.map(awb => 
                `<span class="px-2 py-1 bg-white border border-slate-200 rounded text-xs font-mono text-slate-700">${escapeHtml(awb)}</span>`
            ).join('');
            
            if (awbs.length > 10) {
                previewContainer.innerHTML += `<span class="px-2 py-1 text-xs text-slate-400">+${(awbs.length - 10).toLocaleString()} more</span>`;
            }
            
            if (awbs.length === 0) {
                previewContainer.innerHTML = '<span class="text-xs text-slate-400">No valid AWBs found in selected column</span>';
            }
            
            // Show large file warning for 100+ AWBs
            const big = fullDataMode ? rowsCount : awbs.length;
            if (big > 1000) {
                // Rough ETA: in full-data mode this is fast; in API mode it's slow
                const etaMinutes = fullDataMode ? Math.ceil(big / 20000) : Math.ceil((Math.ceil(big / 20) * 2.5) / 60);
                etaEl.textContent = `~${etaMinutes} minutes`;
                warningEl.classList.remove('hidden');
            } else {
                warningEl.classList.add('hidden');
            }
        }

        function closeExcelPanel() {
            document.getElementById('excelUploadPanel').classList.add('hidden');
        }

        // Excel Import State for large files
        const ExcelImport = {
            isRunning: false,
            isPaused: false,
            currentBatch: 0,
            totalBatches: 0,
            totalSuccess: 0,
            totalFail: 0,
            awbs: [],
            rows: [],
            mode: 'FULL_DATA', // FULL_DATA or AWB_ONLY
            startTime: null,
        };

        async function trackExcelAwbs() {
            const awbs = ExcelUpload.extractedAwbs;

            // We always use FULL_DATA mode (Excel already contains shipment data)
            if (!ExcelUpload.rowObjects || !ExcelUpload.rowObjects.length) {
                showToast('No parsed rows found in Excel. Please check the file and try again.', 'error');
                return;
            }

            closeExcelPanel();

            // Initialize import state
            ExcelImport.isRunning = true;
            ExcelImport.isPaused = false;
            ExcelImport.currentBatch = 0;
            ExcelImport.totalSuccess = 0;
            ExcelImport.totalFail = 0;
            ExcelImport.mode = 'FULL_DATA';
            ExcelImport.awbs = awbs;
            ExcelImport.rows = ExcelUpload.rowObjects || [];
            ExcelImport.startTime = Date.now();

            // Show progress UI
            showExcelImportProgress();

            const rowsCount = ExcelImport.rows.length;
            const estMinutes = Math.max(1, Math.ceil(rowsCount / 20000)); // very rough
            showToast(`Importing ${rowsCount.toLocaleString()} rows from Excel...`, 'info');
            await importShipmentsFromExcelRows();
        }

        function normalizeHeaderKey(key) {
            return String(key || '').toLowerCase().replace(/[^a-z0-9]/g, '');
        }

        function buildRowKeyMap(row) {
            const map = new Map();
            Object.keys(row || {}).forEach(k => {
                const nk = normalizeHeaderKey(k);
                if (!map.has(nk)) map.set(nk, k);
            });
            return map;
        }

        function pickRowValue(row, keyMap, candidates) {
            for (const c of candidates) {
                const actual = keyMap.get(normalizeHeaderKey(c));
                if (actual && row[actual] !== undefined && row[actual] !== null && String(row[actual]).trim() !== '') {
                    return row[actual];
                }
            }
            return '';
        }

        function toBool(v) {
            const s = String(v || '').toLowerCase().trim();
            return s === 'true' || s === '1' || s === 'yes' || s === 'y';
        }

        function toNumber(v) {
            const n = parseFloat(String(v || '').replace(/[^\d.\-]/g, ''));
            return Number.isFinite(n) ? n : 0;
        }

        function normalizeExcelRowToApiData(row) {
            // Prefer the user-selected AWB column if available
            let awb = '';
            if (ExcelUpload.awbHeaderKey && row.hasOwnProperty(ExcelUpload.awbHeaderKey)) {
                awb = String(row[ExcelUpload.awbHeaderKey] || '').trim();
            }

            const keyMap = buildRowKeyMap(row);

            if (!awb) {
                awb = pickRowValue(row, keyMap, ['awb', 'awbnumber', 'awb_number', 'waybill', 'consignment', 'tracking', 'trackingnumber', 'tracking_number', 'awb_no']);
            }
            const statusCode = pickRowValue(row, keyMap, ['currentstatuscode', 'statuscode', 'status_code', 'status']);
            const statusDesc = pickRowValue(row, keyMap, ['currentstatuscodedescription', 'statusdescription', 'status_desc', 'statusdescription', 'currentstatus', 'status']);
            const deliveredOn = pickRowValue(row, keyMap, ['deliveredon', 'deliverydate', 'delivered_date', 'delivery_date']);

            return {
                awbNumber: awb,
                booking_date: pickRowValue(row, keyMap, ['booking_date', 'bookingdate', 'pickup_date', 'pickupdate']),
                pickup_time: pickRowValue(row, keyMap, ['pickup_time', 'pickupdatetime', 'pickup_date', 'pickupdate']),
                ofd_time: pickRowValue(row, keyMap, ['ofd_time', 'ofd_datetime', 'ofddate']),
                first_scan_time: pickRowValue(row, keyMap, ['first_scan_time', 'firstscantime', 'first_scan']),
                last_event_time: pickRowValue(row, keyMap, ['last_event_time', 'lasteventtime', 'last_update_time', 'lastupdatetime']),
                terminal_status: pickRowValue(row, keyMap, ['terminal_status', 'delivery_status', 'status_final']),
                orderNumber: pickRowValue(row, keyMap, ['ordernumber', 'order_number', 'orderid', 'order_id']),
                pieces: toNumber(pickRowValue(row, keyMap, ['pieces', 'piece', 'qty', 'quantity'])) || 1,
                addedOn: pickRowValue(row, keyMap, ['addedon', 'createdat', 'created_at', 'created', 'bookingdate', 'booking_date']),
                invoiceDate: pickRowValue(row, keyMap, ['invoicedate', 'invoice_date']),
                invoiceNumber: pickRowValue(row, keyMap, ['invoicenumber', 'invoice_number', 'invoicevalue', 'invoice_value', 'amount', 'codamount', 'cod_amount', 'value']),
                shipperName: pickRowValue(row, keyMap, [
                    'shippername', 'shipper_name',
                    'customer', 'customername', 'customer_name',
                    'client', 'merchant',
                    'consignee', 'consignee_name',
                    'sender_name', 'sendername', 'sender'
                ]) || pickRowValue(row, keyMap, ['receiver_name', 'receivername', 'receiver']),
                origin: pickRowValue(row, keyMap, ['origin', 'from', 'source']),
                destination: pickRowValue(row, keyMap, ['destination', 'to', 'dest']),
                currentLocation: pickRowValue(row, keyMap, ['currentlocation', 'current_location', 'location', 'hub']),
                edd: pickRowValue(row, keyMap, ['edd', 'expecteddeliverydate', 'expected_delivery_date']),
                currentStatusDateTime: pickRowValue(row, keyMap, ['currentstatusdatetime', 'currentstatusdatetime', 'lastupdate', 'last_update', 'statusdatetime', 'updatedat', 'updated_at']),
                currentStatusCode: statusCode || statusDesc, // if only description exists, normalizeStatusCode can still map
                currentStatusCodeDescription: statusDesc || statusCode,
                currentReasonCode: pickRowValue(row, keyMap, ['reasoncode', 'reason_code']),
                currentReasonCodeDescription: pickRowValue(row, keyMap, ['reason', 'reasondescription', 'reason_description']),
                isRto: toBool(pickRowValue(row, keyMap, ['isrto', 'rto', 'is_rto'])),
                weight: toNumber(pickRowValue(row, keyMap, ['weight', 'wt'])),
                productType: pickRowValue(row, keyMap, ['producttype', 'product_type', 'type', 'paymenttype', 'payment_type']),
                delPod: pickRowValue(row, keyMap, ['delpod', 'pod', 'podurl', 'pod_url']),
                deliveredOn: deliveredOn,
                scans: buildScansFromExcelRow(row, keyMap, deliveredOn),
            };
        }

        /** Build timeline scans from Excel columns: manifest/first_scan, pickup, OFD, delivery */
        function buildScansFromExcelRow(row, keyMap, deliveredOn) {
            const pick = (keys) => pickRowValue(row, keyMap, keys);
            const toTs = (v) => {
                if (!v) return null;
                const d = parseApiDate(v);
                return d ? d.getTime() : null;
            };
            const entries = [];
            const firstScan = pick(['first_scan_time', 'firstscantime', 'first_scan', 'manifest_time', 'manifestdate']);
            if (firstScan) entries.push({ statusCode: 'MAN', statusDateTime: firstScan, statusDescription: 'Manifested', _ts: toTs(firstScan) });
            const pickup = pick(['pickup_time', 'pickupdatetime', 'pickup_date', 'pickupdate', 'booking_date', 'bookingdate']);
            if (pickup) entries.push({ statusCode: 'PKD', statusDateTime: pickup, statusDescription: 'Picked up', _ts: toTs(pickup) });
            const ofd = pick(['ofd_time', 'ofd_datetime', 'ofddate', 'ofd_date']);
            if (ofd) entries.push({ statusCode: 'OFD', statusDateTime: ofd, statusDescription: 'Out for delivery', _ts: toTs(ofd) });
            if (deliveredOn) entries.push({ statusCode: 'DDL', statusDateTime: deliveredOn, statusDescription: 'Delivered', _ts: toTs(deliveredOn) });
            entries.sort((a, b) => (a._ts || 0) - (b._ts || 0));
            return entries.map(({ _ts, ...s }) => s);
        }

        async function importShipmentsFromExcelRows() {
            const rows = ExcelImport.rows || [];
            if (!rows.length) {
                // Fallback: if no headers/objects, use AWB-only mode
                showToast('No row objects found. Switch off full-data mode or ensure headers exist.', 'error');
                ExcelImport.isRunning = false;
                const overlay = document.getElementById('loadingOverlay');
                if (overlay) overlay.classList.add('hidden');
                return;
            }

            // Treat as a streaming import to avoid UI freezing
            const CHUNK_SIZE = 500;
            ExcelImport.totalBatches = Math.ceil(rows.length / CHUNK_SIZE);
            ExcelImport.currentBatch = 0;

            let hadError = false;

            try {
                for (let i = 0; i < rows.length && ExcelImport.isRunning; i++) {
                    while (ExcelImport.isPaused && ExcelImport.isRunning) {
                        await sleep(200);
                    }
                    if (!ExcelImport.isRunning) break;

                    // Update progress at chunk boundaries
                    if (i % CHUNK_SIZE === 0) {
                        ExcelImport.currentBatch = Math.floor(i / CHUNK_SIZE) + 1;
                        updateExcelImportProgress();
                        await sleep(0);
                    }

                    try {
                        const apiData = normalizeExcelRowToApiData(rows[i]);
                        if (!apiData.awbNumber) {
                            ExcelImport.totalFail++;
                            continue;
                        }

                        const shipment = normalizeShipmentData(apiData);
                        // Drop heavy fields for memory/localStorage safety
                        shipment.rawData = undefined;
                        if (Array.isArray(shipment.scans) && shipment.scans.length > 50) {
                            shipment.scans = shipment.scans.slice(0, 50);
                        }

                        ExcelImport.totalSuccess++;
                    } catch (rowError) {
                        console.warn('[ExcelImport] Skipping bad row', rowError);
                        ExcelImport.totalFail++;
                        hadError = true;
                        continue;
                    }
                }

                // Replace state with ALL imported rows (1 row → 1 shipment)
                State.shipments = rows
                    .map(r => {
                        try {
                            return normalizeShipmentData(normalizeExcelRowToApiData(r));
                        } catch (e) {
                            console.warn('[ExcelImport] Failed to normalize row during finalization', e);
                            hadError = true;
                            return null;
                        }
                    })
                    .filter(s => s && s.awb); // keep only rows with AWB

                // Trim heavy fields before caching to improve localStorage reliability
                State.shipments.forEach(s => {
                    if ('rawData' in s) {
                        s.rawData = undefined;
                    }
                    if (Array.isArray(s.scans) && s.scans.length > 50) {
                        s.scans = s.scans.slice(0, 50);
                    }
                });
                State.trackedAwbs = new Set(State.shipments.map(s => s.awb));

                // Render & cache (best-effort)
                updateFilterDropdowns();
                // Auto-reset all filters (same as pressing the Reset button)
                clearFilters();
                updateFailureBucketAlert();

                // Best-effort cache: may exceed quota for 20k rows; we keep UI working even if cache fails
                try {
                    DataLayer.saveCache(State.shipments);
                } catch (e) {
                    console.warn('[ExcelImport] Failed to cache shipments', e);
                }
                DataLayer.updateLastSync();
                updateLastSyncDisplay();
            } catch (e) {
                console.error('[ExcelImport] Fatal import error', e);
                hadError = true;
            } finally {
                // Complete UI cleanup – ALWAYS run, even on errors
                ExcelImport.isRunning = false;
                const overlay = document.getElementById('loadingOverlay');
                if (overlay) {
                    overlay.classList.add('hidden');
                    overlay.innerHTML = `
                        <div class="bg-white rounded-xl p-8 flex flex-col items-center shadow-2xl">
                            <iconify-icon icon="solar:refresh-linear" width="40" class="text-blue-600 animate-spin mb-4"></iconify-icon>
                            <p class="text-slate-900 font-semibold">Tracking Shipments...</p>
                            <p id="loadingStatus" class="text-slate-500 text-sm mt-1">Connecting to API</p>
                        </div>
                    `;
                }

                const duration = Math.round((Date.now() - ExcelImport.startTime) / 1000);
                if (State.shipments && State.shipments.length) {
                    const msg = hadError
                        ? `Excel import completed with some skipped rows. Imported ${State.shipments.length.toLocaleString()} shipments (${duration}s).`
                        : `Imported ${State.shipments.length.toLocaleString()} shipments from Excel (${duration}s)`;
                    showToast(msg, hadError ? 'error' : 'success');
                } else if (hadError) {
                    showToast('Excel import failed. Please check the file format and try again.', 'error');
                }

                // Resume live board if configured
                if (LiveBoard.config.startAwb && LiveBoard.config.endAwb) {
                    LiveBoard.isPaused = false;
                    updateLiveUI();
                    startCountdown();
                }

                updateRateLimitStatus();
            }
        }

        function showExcelImportProgress() {
            // Replace loading overlay with persistent progress bar
            const overlay = document.getElementById('loadingOverlay');
            overlay.innerHTML = `
                <div class="bg-white rounded-2xl p-6 shadow-2xl w-full max-w-lg mx-4">
                    <div class="flex items-center justify-between mb-4">
                        <div class="flex items-center gap-3">
                            <div class="p-2 bg-emerald-100 rounded-lg">
                                <iconify-icon icon="solar:file-text-linear" width="24" class="text-emerald-600"></iconify-icon>
                            </div>
                            <div>
                                <h3 class="font-bold text-slate-900">Excel Import</h3>
                                <p class="text-xs text-slate-500">${(ExcelImport.rows ? ExcelImport.rows.length : 0).toLocaleString()} rows</p>
                            </div>
                        </div>
                        <button onclick="toggleExcelImportPause()" id="excelPauseBtn" class="px-3 py-1.5 text-xs font-semibold text-amber-700 bg-amber-100 rounded-lg hover:bg-amber-200 transition-all">
                            Pause
                        </button>
                    </div>
                    
                    <div class="mb-4">
                        <div class="flex items-center justify-between text-xs text-slate-500 mb-1">
                            <span id="excelImportStatus">Processing...</span>
                            <span id="excelImportPercent">0%</span>
                        </div>
                        <div class="w-full bg-slate-100 rounded-full h-3 overflow-hidden">
                            <div id="excelImportBar" class="bg-gradient-to-r from-emerald-500 to-teal-500 h-3 rounded-full transition-all duration-300" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-4 gap-3 text-center">
                        <div class="bg-slate-50 rounded-lg p-2">
                            <p class="text-lg font-bold text-slate-900" id="excelBatchNum">0</p>
                            <p class="text-[10px] text-slate-500">Batch</p>
                        </div>
                        <div class="bg-emerald-50 rounded-lg p-2">
                            <p class="text-lg font-bold text-emerald-600" id="excelSuccessNum">0</p>
                            <p class="text-[10px] text-slate-500">Found</p>
                        </div>
                        <div class="bg-slate-50 rounded-lg p-2">
                            <p class="text-lg font-bold text-slate-400" id="excelFailNum">0</p>
                            <p class="text-[10px] text-slate-500">Not Found</p>
                        </div>
                        <div class="bg-blue-50 rounded-lg p-2">
                            <p class="text-lg font-bold text-blue-600" id="excelEtaNum">--</p>
                            <p class="text-[10px] text-slate-500">ETA (min)</p>
                        </div>
                    </div>
                    
                    <p class="text-[10px] text-slate-400 text-center mt-3">
                        Processing in batches of 20 with rate limit protection
                    </p>
                </div>
            `;
            overlay.classList.remove('hidden');
        }

        function updateExcelImportProgress() {
            const percent = Math.round((ExcelImport.currentBatch / ExcelImport.totalBatches) * 100);
            const elapsed = (Date.now() - ExcelImport.startTime) / 1000;
            const avgBatchTime = ExcelImport.currentBatch > 0 ? elapsed / ExcelImport.currentBatch : 2.5;
            const remainingBatches = ExcelImport.totalBatches - ExcelImport.currentBatch;
            const etaMinutes = Math.ceil((remainingBatches * avgBatchTime) / 60);
            
            document.getElementById('excelImportBar').style.width = `${percent}%`;
            document.getElementById('excelImportPercent').textContent = `${percent}%`;
            document.getElementById('excelBatchNum').textContent = `${ExcelImport.currentBatch}/${ExcelImport.totalBatches}`;
            document.getElementById('excelSuccessNum').textContent = ExcelImport.totalSuccess.toLocaleString();
            document.getElementById('excelFailNum').textContent = ExcelImport.totalFail.toLocaleString();
            document.getElementById('excelEtaNum').textContent = etaMinutes > 0 ? etaMinutes : '<1';
            
            const status = ExcelImport.isPaused ? 'Paused' : `Batch ${ExcelImport.currentBatch} of ${ExcelImport.totalBatches}`;
            document.getElementById('excelImportStatus').textContent = status;
        }

        function toggleExcelImportPause() {
            ExcelImport.isPaused = !ExcelImport.isPaused;
            const btn = document.getElementById('excelPauseBtn');
            
            if (ExcelImport.isPaused) {
                btn.textContent = 'Resume';
                btn.classList.remove('text-amber-700', 'bg-amber-100', 'hover:bg-amber-200');
                btn.classList.add('text-emerald-700', 'bg-emerald-100', 'hover:bg-emerald-200');
                showToast('Import paused. Click Resume to continue.', 'info');
            } else {
                btn.textContent = 'Pause';
                btn.classList.add('text-amber-700', 'bg-amber-100', 'hover:bg-amber-200');
                btn.classList.remove('text-emerald-700', 'bg-emerald-100', 'hover:bg-emerald-200');
                showToast('Import resumed', 'success');
            }
            
            updateExcelImportProgress();
        }

        async function processExcelBatches(batchSize) {
            const { awbs, totalBatches } = ExcelImport;
            
            for (let i = ExcelImport.currentBatch; i < totalBatches && ExcelImport.isRunning; i++) {
                // Check if paused
                while (ExcelImport.isPaused && ExcelImport.isRunning) {
                    await sleep(500);
                }
                
                if (!ExcelImport.isRunning) break;
                
                ExcelImport.currentBatch = i + 1;
                updateExcelImportProgress();
                
                const start = i * batchSize;
                const end = Math.min(start + batchSize, awbs.length);
                const batch = awbs.slice(start, end);
                
                try {
                    const results = await API.tracking.getMultiple(batch);
                    
                    results.forEach(result => {
                        if (result.success && result.data) {
                            const shipment = normalizeShipmentData(result.data);
                            const existingIndex = State.shipments.findIndex(s => s.awb === shipment.awb);
                            if (existingIndex >= 0) {
                                State.shipments[existingIndex] = shipment;
                            } else {
                                State.shipments.unshift(shipment);
                            }
                            State.trackedAwbs.add(shipment.awb);
                            DataLayer.addAwb(shipment.awb);
                            ExcelImport.totalSuccess++;
                        } else {
                            ExcelImport.totalFail++;
                        }
                    });
                    
                    // Save every 5 batches to reduce I/O
                    if (i % 5 === 0 || i === totalBatches - 1) {
                        DataLayer.saveCache(State.shipments);
                        updateFilterDropdowns();
                        applyFiltersAndRender();
                    }
                    
                    updateExcelImportProgress();
                    
                    // Delay between batches (2 seconds for rate limit safety)
                    if (i < totalBatches - 1) {
                        await sleep(2000);
                    }
                    
                } catch (batchError) {
                    console.error(`[Excel] Batch ${i + 1} error:`, batchError);
                    ExcelImport.totalFail += batch.length;
                    
                    if (batchError.message && batchError.message.includes('Rate limit')) {
                        document.getElementById('excelImportStatus').textContent = 'Rate limited - waiting 10s...';
                        await sleep(10000);
                    } else {
                        await sleep(2000);
                    }
                }
            }
            
            // Complete
            ExcelImport.isRunning = false;
            DataLayer.saveCache(State.shipments);
            DataLayer.updateLastSync();
            updateLastSyncDisplay();
            updateFilterDropdowns();
            applyFiltersAndRender();
            
            // Hide progress overlay
            document.getElementById('loadingOverlay').classList.add('hidden');
            
            // Restore loading overlay HTML
            document.getElementById('loadingOverlay').innerHTML = `
                <div class="bg-white rounded-xl p-8 flex flex-col items-center shadow-2xl">
                    <iconify-icon icon="solar:refresh-linear" width="40" class="text-blue-600 animate-spin mb-4"></iconify-icon>
                    <p class="text-slate-900 font-semibold">Tracking Shipments...</p>
                    <p id="loadingStatus" class="text-slate-500 text-sm mt-1">Connecting to API</p>
                </div>
            `;
            
            // Show completion toast
            const duration = Math.round((Date.now() - ExcelImport.startTime) / 1000 / 60);
            showToast(
                `Excel import complete: ${ExcelImport.totalSuccess.toLocaleString()} found, ${ExcelImport.totalFail.toLocaleString()} not found (${duration} min)`, 
                ExcelImport.totalFail > 0 ? 'info' : 'success'
            );
            
            // Resume live board if configured
            if (LiveBoard.config.startAwb && LiveBoard.config.endAwb) {
                LiveBoard.isPaused = false;
                updateLiveUI();
                startCountdown();
            }
            
            updateRateLimitStatus();
        }

        // =====================================================
        // LIVE BOARD - AUTOMATIC CONTINUOUS TRACKING
        // =====================================================
        const LiveBoard = {
            isRunning: false,
            isPaused: false,
            currentBatch: 0,
            totalBatches: 0,
            foundCount: 0,
            awbsToFetch: [],
            batchSize: 20,
            delayBetweenBatches: 2000, // 2 seconds between batches
            refreshInterval: 300, // 5 minutes default (in seconds)
            countdownTimer: null,
            countdownSeconds: 0,
            config: {
                startAwb: '',
                endAwb: '',
                interval: 300,
            },
            CONFIG_KEY: 'urbanebolt_liveboard_config',
        };

        // Load saved config
        function loadLiveBoardConfig() {
            try {
                const saved = localStorage.getItem(LiveBoard.CONFIG_KEY);
                if (saved) {
                    const config = JSON.parse(saved);
                    LiveBoard.config = { ...LiveBoard.config, ...config };
                    LiveBoard.refreshInterval = config.interval || 300;
                    
                    // Populate inputs
                    document.getElementById('awbSeriesStart').value = config.startAwb || '';
                    document.getElementById('awbSeriesEnd').value = config.endAwb || '';
                    document.getElementById('refreshInterval').value = config.interval || 300;
                }
            } catch (e) {
                console.warn('[LiveBoard] Failed to load config:', e);
            }
        }

        // Save config
        function saveLiveBoardConfig() {
            try {
                localStorage.setItem(LiveBoard.CONFIG_KEY, JSON.stringify(LiveBoard.config));
            } catch (e) {
                console.warn('[LiveBoard] Failed to save config:', e);
            }
        }

        function generateAwbSeries(start, end) {
            const startNum = parseInt(start);
            const endNum = parseInt(end);
            
            if (isNaN(startNum) || isNaN(endNum)) {
                throw new Error('Invalid AWB numbers. Must be numeric.');
            }
            
            if (endNum < startNum) {
                throw new Error('End AWB must be greater than Start AWB');
            }
            
            const count = endNum - startNum + 1;
            if (count > 50000) {
                throw new Error('Maximum 50,000 AWBs in a series. Please reduce the range.');
            }
            
            const awbs = [];
            for (let i = startNum; i <= endNum; i++) {
                awbs.push(String(i));
            }
            return awbs;
        }

        function updateLiveUI() {
            const dot = document.getElementById('liveDot');
            const statusText = document.getElementById('liveStatusText');
            const rangeDisplay = document.getElementById('liveRangeDisplay');
            const countdown = document.getElementById('nextRefreshCountdown');
            const progressBar = document.getElementById('liveProgressBar');
            const progressLabel = document.getElementById('liveProgressLabel');
            const progressStats = document.getElementById('liveProgressStats');
            const toggleBtn = document.getElementById('liveModeToggle');
            const toggleIcon = document.getElementById('liveModeIcon');
            const toggleText = document.getElementById('liveModeText');
            const indicator = document.getElementById('liveIndicator');

            // Update range display
            if (LiveBoard.config.startAwb && LiveBoard.config.endAwb) {
                rangeDisplay.textContent = `AWB: ${LiveBoard.config.startAwb} → ${LiveBoard.config.endAwb}`;
            } else {
                rangeDisplay.textContent = 'AWB Range: Not configured';
            }

            if (LiveBoard.isPaused) {
                dot.classList.remove('animate-pulse', 'bg-white');
                dot.classList.add('bg-yellow-400');
                statusText.textContent = 'PAUSED';
                indicator.classList.remove('bg-white/20');
                indicator.classList.add('bg-yellow-500/30');
                toggleIcon.setAttribute('icon', 'solar:play-linear');
                toggleText.textContent = 'Resume';
                countdown.textContent = 'PAUSED';
            } else if (LiveBoard.isRunning) {
                dot.classList.add('animate-pulse', 'bg-white');
                dot.classList.remove('bg-yellow-400');
                statusText.textContent = 'SCANNING';
                indicator.classList.add('bg-white/20');
                indicator.classList.remove('bg-yellow-500/30');
                toggleIcon.setAttribute('icon', 'solar:pause-linear');
                toggleText.textContent = 'Pause';
                
                const processed = LiveBoard.currentBatch * LiveBoard.batchSize;
                const total = LiveBoard.awbsToFetch.length;
                const percent = total > 0 ? Math.round((processed / total) * 100) : 0;
                
                progressBar.style.width = `${percent}%`;
                progressLabel.textContent = `Batch ${LiveBoard.currentBatch}/${LiveBoard.totalBatches}`;
                progressStats.textContent = `${Math.min(processed, total)}/${total} AWBs • Found: ${LiveBoard.foundCount}`;
                countdown.textContent = 'SCANNING';
            } else {
                dot.classList.add('animate-pulse', 'bg-white');
                dot.classList.remove('bg-yellow-400');
                statusText.textContent = 'LIVE';
                indicator.classList.add('bg-white/20');
                indicator.classList.remove('bg-yellow-500/30');
                toggleIcon.setAttribute('icon', 'solar:pause-linear');
                toggleText.textContent = 'Pause';
                
                progressBar.style.width = '100%';
                progressLabel.textContent = `Last scan: ${LiveBoard.foundCount} shipments`;
                progressStats.textContent = `Total tracked: ${State.shipments.length}`;
            }
        }

        function updateCountdown() {
            const countdown = document.getElementById('nextRefreshCountdown');
            if (LiveBoard.isPaused || LiveBoard.isRunning) return;
            
            const mins = Math.floor(LiveBoard.countdownSeconds / 60);
            const secs = LiveBoard.countdownSeconds % 60;
            countdown.textContent = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            
            if (LiveBoard.countdownSeconds <= 0) {
                startLiveScan();
            } else {
                LiveBoard.countdownSeconds--;
            }
        }

        function startCountdown() {
            if (LiveBoard.countdownTimer) {
                clearInterval(LiveBoard.countdownTimer);
            }
            LiveBoard.countdownSeconds = LiveBoard.refreshInterval;
            LiveBoard.countdownTimer = setInterval(updateCountdown, 1000);
            updateCountdown();
        }

        function toggleLiveSettings() {
            const panel = document.getElementById('liveSettingsPanel');
            panel.classList.toggle('hidden');
        }

        function applyLiveSettings() {
            const startAwb = document.getElementById('awbSeriesStart').value.trim();
            const endAwb = document.getElementById('awbSeriesEnd').value.trim();
            const interval = parseInt(document.getElementById('refreshInterval').value);
            
            if (!startAwb || !endAwb) {
                showToast('Please enter both Start and End AWB numbers', 'error');
                return;
            }
            
            try {
                // Validate range
                generateAwbSeries(startAwb, endAwb);
                
                LiveBoard.config.startAwb = startAwb;
                LiveBoard.config.endAwb = endAwb;
                LiveBoard.config.interval = interval;
                LiveBoard.refreshInterval = interval;
                
                saveLiveBoardConfig();
                toggleLiveSettings();
                updateLiveUI();
                
                showToast('Settings saved! Starting scan...', 'success');
                
                // Start scanning immediately
                startLiveScan();
                
            } catch (error) {
                showToast(error.message, 'error');
            }
        }

        function toggleLiveMode() {
            LiveBoard.isPaused = !LiveBoard.isPaused;
            
            if (LiveBoard.isPaused) {
                // Pause - stop countdown
                if (LiveBoard.countdownTimer) {
                    clearInterval(LiveBoard.countdownTimer);
                }
                showToast('Live board paused', 'info');
            } else {
                // Resume - start countdown
                if (LiveBoard.config.startAwb && LiveBoard.config.endAwb) {
                    showToast('Live board resumed', 'success');
                    startCountdown();
                } else {
                    showToast('Please configure AWB range first', 'warning');
                    toggleLiveSettings();
                    LiveBoard.isPaused = true;
                }
            }
            
            updateLiveUI();
        }

        async function startLiveScan() {
            if (LiveBoard.isRunning || LiveBoard.isPaused) return;
            
            const { startAwb, endAwb } = LiveBoard.config;
            
            if (!startAwb || !endAwb) {
                // No config - show settings
                toggleLiveSettings();
                return;
            }
            
            try {
                const awbs = generateAwbSeries(startAwb, endAwb);
                
                // Reset state
                LiveBoard.isRunning = true;
                LiveBoard.currentBatch = 0;
                LiveBoard.totalBatches = Math.ceil(awbs.length / LiveBoard.batchSize);
                LiveBoard.foundCount = 0;
                LiveBoard.awbsToFetch = awbs;
                
                updateLiveUI();
                
                // Process batches
                await processLiveBatches();
                
            } catch (error) {
                console.error('[LiveBoard] Scan error:', error);
                LiveBoard.isRunning = false;
                updateLiveUI();
            }
        }

        async function processLiveBatches() {
            const { awbsToFetch, batchSize, totalBatches, delayBetweenBatches } = LiveBoard;
            
            for (let i = 0; i < totalBatches && LiveBoard.isRunning && !LiveBoard.isPaused; i++) {
                LiveBoard.currentBatch = i + 1;
                updateLiveUI();
                
                const start = i * batchSize;
                const end = Math.min(start + batchSize, awbsToFetch.length);
                const batchAwbs = awbsToFetch.slice(start, end);
                
                try {
                    const results = await API.tracking.getMultiple(batchAwbs);
                    
                    results.forEach(result => {
                        if (result.success && result.data) {
                            const shipment = normalizeShipmentData(result.data);
                            const existingIndex = State.shipments.findIndex(s => s.awb === shipment.awb);
                            if (existingIndex >= 0) {
                                State.shipments[existingIndex] = shipment;
                            } else {
                                State.shipments.unshift(shipment);
                            }
                            State.trackedAwbs.add(shipment.awb);
                            DataLayer.addAwb(shipment.awb);
                            LiveBoard.foundCount++;
                        }
                    });
                    
                    // Update display after each batch
                    DataLayer.saveCache(State.shipments);
                    updateFilterDropdowns();
                    applyFiltersAndRender();
                    updateLiveUI();
                    
                    // Delay before next batch
                    if (i < totalBatches - 1 && LiveBoard.isRunning && !LiveBoard.isPaused) {
                        await sleep(delayBetweenBatches);
                    }
                    
                } catch (error) {
                    console.error(`[LiveBoard] Batch ${i + 1} error:`, error);
                    if (error.message && error.message.includes('Rate limit')) {
                        await sleep(5000);
                    }
                }
            }
            
            // Complete - schedule next scan
            LiveBoard.isRunning = false;
            DataLayer.updateLastSync();
            updateLastSyncDisplay();
            updateLiveUI();
            updateRateLimitStatus();
            
            if (!LiveBoard.isPaused) {
                startCountdown();
            }
        }

        // Legacy function for manual start
        function startLiveBoard() {
            applyLiveSettings();
        }

        function stopLiveBoard() {
            LiveBoard.isPaused = true;
            LiveBoard.isRunning = false;
            if (LiveBoard.countdownTimer) {
                clearInterval(LiveBoard.countdownTimer);
            }
            updateLiveUI();
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Auto-start live board on page load
        function initLiveBoard() {
            loadLiveBoardConfig();
            updateLiveUI();
            
            // Auto-start if configured
            if (LiveBoard.config.startAwb && LiveBoard.config.endAwb) {
                setTimeout(() => {
                    startLiveScan();
                }, 2000); // 2 second delay after page load
            } else {
                // Show settings panel if not configured
                setTimeout(() => {
                    toggleLiveSettings();
                }, 1000);
            }
        }

        // =====================================================
        // NORMALIZE API DATA
        // =====================================================
        /**
         * Normalize API response data to internal format
         * API Response Fields:
         *   awbNumber, orderNumber, pieces, addedOn, invoiceDate, invoiceNumber,
         *   shipperName, origin, destination, currentLocation, edd,
         *   currentStatusDateTime, currentStatusCode, currentStatusCodeDescription,
         *   currentReasonCode, currentReasonCodeDescription, isRto, weight,
         *   productType (PPD/COD), delPod, scans[]
         */
        function normalizeShipmentData(apiData) {
            // Calculate route string
            const route = `${apiData.origin || 'N/A'} → ${apiData.destination || 'N/A'}`;
            
            // Determine invoice/value from invoiceNumber or use 0 for PPD
            const invoiceValue = parseFloat(apiData.invoiceNumber || 0) || 0;
            
            // Get normalized status code
            const statusCode = normalizeStatusCode(apiData.currentStatusCode);
            
            // Calculate lifecycle metrics
            const lifecycle = calculateLifecycleMetrics(apiData, statusCode);
            
            return {
                awb: String(apiData.awbNumber || ''),
                orderNumber: apiData.orderNumber || '',
                customer: apiData.shipperName || 'N/A',
                origin: apiData.origin || 'N/A',
                destination: apiData.destination || 'N/A',
                route: route,
                currentLocation: apiData.currentLocation || apiData.destination || '',
                value: apiData.productType === 'COD' ? invoiceValue : 0,
                status: apiData.currentStatusCodeDescription || apiData.currentStatusCode || 'Unknown',
                statusCode: statusCode,
                type: apiData.productType || 'PPD',
                lastUpdate: apiData.currentStatusDateTime || '',
                addedOn: apiData.addedOn || '',
                edd: apiData.edd || '',
                eddDate: lifecycle.eddDate,
                weight: apiData.weight || 0,
                pieces: apiData.pieces || 1,
                isRto: apiData.isRto || false,
                rtoStatus: apiData.rto_status || 0,
                delPod: apiData.delPod || '',
                reasonCode: apiData.currentReasonCode || '',
                reasonDescription: apiData.currentReasonCodeDescription || '',
                scans: apiData.scans || [],
                rawData: apiData,
                
                // Lifecycle & SLA fields
                createdAt: lifecycle.createdAt,
                deliveredAt: lifecycle.deliveredAt,
                shipmentAgeDays: lifecycle.shipmentAgeDays,
                delayedDays: lifecycle.delayedDays,
                tatExpectedDays: lifecycle.tatExpectedDays,
                tatActualDays: lifecycle.tatActualDays,
                tatBreach: lifecycle.tatBreach,
                tatOnTime: lifecycle.tatOnTime,
                ofdAgeingDays: lifecycle.ofdAgeingDays,
                isOfdAgeing: lifecycle.isOfdAgeing,
                isTerminal: lifecycle.isTerminal,
                lifecycleBreach: lifecycle.lifecycleBreach,
                isDelayed: lifecycle.isDelayed,
                isInFailureBucket: lifecycle.isInFailureBucket,
                failureReasons: lifecycle.failureReasons,
                slaStatus: lifecycle.slaStatus,
                terminalStatus: lifecycle.terminalStatus,
                isDeliveredSuccess: lifecycle.isDeliveredSuccess,
                isDeliveredLate: lifecycle.isDeliveredLate,
                rdcDangerNoOfdToday: lifecycle.rdcDangerNoOfdToday,
                rdcOfdLate: lifecycle.rdcOfdLate,
            };
        }

        /** Map MongoDB document (from GET /api/v1/dashboard/shipments) to UI shipment shape with correct delay & lifecycle */
        function mongoDocToShipment(doc) {
            const route = `${doc.origin || 'N/A'} → ${doc.destination || 'N/A'}`;
            const lastUpdate = doc.deliveredOn || doc.uploadedAt || doc.bookingDate || '';
            const eddStr = doc.edd ? (typeof doc.edd === 'string' ? doc.edd : new Date(doc.edd).toISOString()) : '';

            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const bookingAt = parseApiDate(doc.bookingDate);
            const eddDate = parseApiDate(doc.edd);
            const deliveredAt = parseApiDate(doc.deliveredOn);
            const isDelivered = !!deliveredAt;
            const isRto = Boolean(doc.isRTO);

            let shipmentAgeDays = null;
            if (bookingAt) {
                const end = deliveredAt || today;
                shipmentAgeDays = Math.max(0, Math.floor((end.getTime() - bookingAt.getTime()) / (1000 * 60 * 60 * 24)));
            } else if (doc.agingDays != null) {
                shipmentAgeDays = Math.max(0, Math.floor(Number(doc.agingDays)));
            }

            let delayedDays = null;
            if (eddDate) {
                const actualDeliveryDate = deliveredAt || today;
                delayedDays = Math.floor((eddDate.getTime() - actualDeliveryDate.getTime()) / (1000 * 60 * 60 * 24));
            }
            const isDelayed = delayedDays !== null && delayedDays < 0;

            const LIFECYCLE_LIMIT_DAYS = 15;
            const lifecycleBreach = (shipmentAgeDays != null && shipmentAgeDays > LIFECYCLE_LIMIT_DAYS && !isDelivered) || Boolean(doc.slaBreach);

            let currentLocation = doc.destination || '';
            if (isDelivered) currentLocation = 'Delivered';
            else if (isRto) currentLocation = 'RTO';
            else if (doc.status) currentLocation = String(doc.status);

            let statusCode = (doc.status || '').toUpperCase();
            if (isDelivered) statusCode = 'DELIVERED';
            else if (isRto) statusCode = 'RTO';

            const terminalStatus = isDelivered ? 'delivered' : (isRto ? 'rto' : '');
            const failureReasons = [];
            if (isRto) failureReasons.push('RTO');
            if (lifecycleBreach) failureReasons.push('Lifecycle breach');
            const isInFailureBucket = isRto || lifecycleBreach;

            var scans = [];
            if (doc.bookingDate) scans.push({ statusCode: 'PKD', statusDateTime: doc.bookingDate, statusDescription: 'Picked up' });
            if (doc.deliveredOn) scans.push({ statusCode: 'DDL', statusDateTime: doc.deliveredOn, statusDescription: 'Delivered' });

            return {
                awb: String(doc.awb || ''),
                orderNumber: '',
                customer: doc.customer || 'N/A',
                origin: doc.origin || 'N/A',
                destination: doc.destination || 'N/A',
                route: route,
                currentLocation: currentLocation,
                value: Number(doc.invoiceValue) || 0,
                status: doc.status || (isDelivered ? 'Delivered' : isRto ? 'RTO' : 'N/A'),
                statusCode: statusCode,
                type: 'PPD',
                lastUpdate: lastUpdate,
                addedOn: doc.bookingDate || '',
                edd: eddStr,
                eddDate: eddStr,
                weight: Number(doc.weight) || 0,
                pieces: Math.max(0, Math.floor(Number(doc.pieces) || 1)),
                isRto: isRto,
                rtoStatus: isRto ? 1 : 0,
                delPod: doc.delPod || '',
                reasonCode: '',
                reasonDescription: '',
                scans: scans,
                rawData: doc,
                slaStatus: doc.slaStatus || (doc.slaBreach ? 'BREACH' : ''),
                deliveryTAT: doc.deliveryTAT != null ? doc.deliveryTAT : null,
                agingDays: doc.agingDays != null ? doc.agingDays : null,
                slaBreach: Boolean(doc.slaBreach),
                createdAt: doc.bookingDate || null,
                deliveredAt: doc.deliveredOn || null,
                shipmentAgeDays: shipmentAgeDays,
                delayedDays: delayedDays,
                tatExpectedDays: null,
                tatActualDays: doc.deliveryTAT != null ? doc.deliveryTAT : null,
                tatBreach: Boolean(doc.slaBreach),
                tatOnTime: !doc.slaBreach,
                ofdAgeingDays: null,
                isOfdAgeing: false,
                isTerminal: isDelivered || isRto,
                lifecycleBreach: lifecycleBreach,
                isDelayed: isDelayed,
                isInFailureBucket: isInFailureBucket,
                failureReasons: failureReasons,
                terminalStatus: terminalStatus.toUpperCase(),
                isDeliveredSuccess: isDelivered,
                isDeliveredLate: Boolean(doc.slaBreach),
                rdcDangerNoOfdToday: false,
                rdcOfdLate: false,
            };
        }

        /**
         * Calculate full SLA / lifecycle metrics for a shipment
         * Implements:
         * - TAT SLA (primary)
         * - EDD delay (secondary)
         * - OFD ageing
         * - Lifecycle breach
         * - Failure bucket membership
         */
        function calculateLifecycleMetrics(apiData, statusCode) {
            const LIFECYCLE_LIMIT_DAYS = 15;
            const TERMINAL_STATUSES = ['DELIVERED', 'RTO', 'CANCELLED', 'LOST'];
            const FAILURE_TERMINAL_STATUSES = ['DDL', 'RTO', 'UD', 'SAL', 'LOST', 'DAMAGED'];

            // Today (IST-ish) at midnight
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Booking / pickup dates
            const bookingAt = parseApiDate(
                apiData.booking_date || apiData.addedOn || apiData.pickup_time || apiData.first_scan_time
            );
            const pickupAt = parseApiDate(
                apiData.pickup_time || apiData.first_scan_time || apiData.booking_date || apiData.addedOn
            );

            // EDD
            const eddDate = parseApiDate(apiData.edd || apiData.edd_date || apiData.expected_delivery_date);

            // Delivery time
            let deliveredAt = null;
            if (apiData.delivered_at) {
                deliveredAt = new Date(apiData.delivered_at);
            } else if (statusCode === 'DELIVERED' && apiData.scans && apiData.scans.length > 0) {
                const deliveryScan = apiData.scans.find(s => s.statusCode === 'DDL' || s.statusCode === 'DELIVERED');
                if (deliveryScan) deliveredAt = new Date(deliveryScan.statusDateTime);
            } else if (apiData.deliveredOn) {
                deliveredAt = parseApiDate(apiData.deliveredOn);
            } else if (apiData.last_event_time) {
                deliveredAt = new Date(apiData.last_event_time);
            }
            if (deliveredAt) {
                // Normalize to midnight for day math
                deliveredAt.setHours(0, 0, 0, 0);
            }

            // OFD / RDC analysis
            let ofdAt = parseApiDate(apiData.ofd_time);
            const scans = Array.isArray(apiData.scans) ? apiData.scans : [];
            if (!ofdAt && scans.length > 0) {
                const ofdScan = scans.find(s => s.statusCode === 'OFD');
                if (ofdScan) ofdAt = parseApiDate(ofdScan.statusDateTime);
            }

            // Lifecycle age
            let lifecycleDays = 0;
            if (bookingAt) {
                lifecycleDays = Math.floor((today - bookingAt) / (1000 * 60 * 60 * 24));
            }

            // Terminal status (normalize different provider / Excel variants)
            let terminalStatusRaw = (apiData.terminal_status || '').toString().trim().toLowerCase();
            let terminalStatus = '';

            if (terminalStatusRaw) {
                if (['delivered', 'ddl', 'del'].includes(terminalStatusRaw)) {
                    terminalStatus = 'delivered';
                } else if (terminalStatusRaw.startsWith('rto')) {
                    terminalStatus = 'rto';
                } else if (['ndr', 'ud'].includes(terminalStatusRaw) || terminalStatusRaw.startsWith('undeliver')) {
                    terminalStatus = 'ud';
                } else if (terminalStatusRaw.includes('lost')) {
                    terminalStatus = 'lost';
                } else if (terminalStatusRaw.includes('cancel')) {
                    terminalStatus = 'cancelled';
                } else {
                    terminalStatus = terminalStatusRaw;
                }
            }

            // If terminal_status is missing, derive from normalized statusCode
            if (!terminalStatus) {
                if (statusCode === 'DELIVERED') terminalStatus = 'delivered';
                else if (statusCode === 'RTO') terminalStatus = 'rto';
                else if (statusCode === 'NDR') terminalStatus = 'ud';
            }
            const isTerminal = TERMINAL_STATUSES.includes(statusCode) || !!terminalStatus;

            // TAT SLA (kept for metrics, but breaches are not used in UI for now)
            let tatExpectedDays = null;
            let tatActualDays = null;
            const originCity = apiData.origin || apiData.origin_city;
            const destCity = apiData.destination || apiData.destination_city;
            if (originCity && destCity) {
                tatExpectedDays = laneSlaDays(originCity, destCity, pickupAt, eddDate);
            }
            if (pickupAt && tatExpectedDays !== null) {
                const tatEnd = deliveredAt || today;
                tatActualDays = Math.max(
                    0,
                    Math.floor((tatEnd - pickupAt) / (1000 * 60 * 60 * 24))
                );
            }
            const tatBreach = false;
            const tatOnTime = terminalStatus === 'delivered';

            // EDD delay (secondary)
            let delayedDays = null;
            if (eddDate) {
                const actualDeliveryDate = deliveredAt || today;
                // NOTE: late = negative values, as per UI:
                // 1 day late  → -1, 2 days late → -2, etc.
                delayedDays = Math.floor((eddDate - actualDeliveryDate) / (1000 * 60 * 60 * 24));
            }
            const isDelayed = delayedDays !== null && delayedDays < 0;

            // OFD ageing
            let ofdAgeingDays = 0;
            const isOfdAgeing = false;

            // Lifecycle breach (>15 days, non-terminal) – still disabled for now
            const lifecycleBreach = false;

            // Failure bucket: for now, treat **RTO** as hard failure bucket and
            // also treat certain RDC/OFD issues as dangerous failures.
            const failureReasons = [];
            let isInFailureBucket = false;
            if (terminalStatus === 'rto') {
                isInFailureBucket = true;
                failureReasons.push('RTO');
            }

            // RDC + OFD business rules
            // 1) If shipment stage is RDC and there is no OFD for that date → dangerous failure
            // 2) If stage is RDC and next OFD (or "now" if none) is >60 minutes later → orange warning
            let rdcDangerNoOfdToday = false;
            let rdcOfdLate = false;

            if (scans.length > 0) {
                // Helper to parse full datetime from scan (keep time component)
                const parseScanDateTime = (value) => {
                    if (!value) return null;
                    const d = new Date(value);
                    return isNaN(d.getTime()) ? null : d;
                };
                const sameCalendarDay = (d1, d2) =>
                    d1 && d2 &&
                    d1.getFullYear() === d2.getFullYear() &&
                    d1.getMonth() === d2.getMonth() &&
                    d1.getDate() === d2.getDate();

                // Sort scans chronologically (oldest → newest)
                const scansWithTs = scans
                    .map(s => ({ ...s, _ts: parseScanDateTime(s.statusDateTime) }))
                    .filter(s => s._ts)
                    .sort((a, b) => a._ts - b._ts);

                let rdcScan = null;
                let ofdAfterRdc = null;

                for (const scan of scansWithTs) {
                    if (scan.statusCode === 'RDC') {
                        rdcScan = scan; // last RDC in the sequence
                        ofdAfterRdc = null; // reset, we only care about OFD after the latest RDC
                    } else if (rdcScan && !ofdAfterRdc && scan.statusCode === 'OFD' && scan._ts >= rdcScan._ts) {
                        ofdAfterRdc = scan;
                    }
                }

                if (rdcScan) {
                    const rdcTs = rdcScan._ts;
                    const now = new Date();

                    // Current stage considered "RDC" if:
                    // - currentStatusCode is RDC, OR
                    // - the last scan's statusCode is RDC
                    const lastScan = scansWithTs[scansWithTs.length - 1];
                    const isRdcStage =
                        String(apiData.currentStatusCode || '').toUpperCase() === 'RDC' ||
                        (lastScan && lastScan.statusCode === 'RDC');

                    if (isRdcStage) {
                        // Rule 1: no OFD on the same calendar date as RDC scan
                        const hasOfdSameDay = scansWithTs.some(s =>
                            s.statusCode === 'OFD' && sameCalendarDay(rdcTs, s._ts)
                        );
                        if (!hasOfdSameDay) {
                            rdcDangerNoOfdToday = true;
                            isInFailureBucket = true;
                            failureReasons.push('RDC without OFD today');
                        }

                        // Rule 2: OFD should happen within 60 minutes of RDC
                        let minutesToOfd = null;
                        if (ofdAfterRdc && ofdAfterRdc._ts) {
                            minutesToOfd = (ofdAfterRdc._ts.getTime() - rdcTs.getTime()) / 60000;
                        } else {
                            minutesToOfd = (now.getTime() - rdcTs.getTime()) / 60000;
                        }
                        if (minutesToOfd !== null && minutesToOfd > 60) {
                            rdcOfdLate = true;
                        }
                    }
                }
            }

            // Delivery success rule simplified: any delivered is success, RTO is failure, others pending
            const isDeliveredSuccess = terminalStatus === 'delivered';
            const isDeliveredLate = false;

            // SLA status label (for badge)
            let slaStatus = 'PENDING';
            if (terminalStatus === 'delivered') {
                slaStatus = 'ONTIME';
            } else if (terminalStatus === 'rto') {
                slaStatus = 'FAILURE';
            }

            return {
                createdAt: bookingAt,
                deliveredAt,
                eddDate,
                shipmentAgeDays: lifecycleDays,
                delayedDays,
                tatExpectedDays,
                tatActualDays,
                tatBreach,
                tatOnTime,
                ofdAgeingDays,
                isOfdAgeing,
                isTerminal,
                lifecycleBreach,
                isDelayed,
                isInFailureBucket,
                failureReasons,
                slaStatus,
                terminalStatus,
                isDeliveredSuccess,
                isDeliveredLate,
                rdcDangerNoOfdToday,
                rdcOfdLate,
            };
        }

        /**
         * Parse various date formats from API
         */
        function parseApiDate(dateStr) {
            if (!dateStr) return null;
            try {
                if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                    const [year, month, day] = dateStr.split('-').map(Number);
                    const date = new Date(year, month - 1, day);
                    date.setHours(0, 0, 0, 0);
                    return date;
                }
                const months = { 'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5,
                    'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11 };
                const match = dateStr.match(/(\d{1,2})\s+(\w{3})\s+(\d{4})/);
                if (match) {
                    const [, day, monthStr, year] = match;
                    const month = months[monthStr];
                    if (month !== undefined) {
                        const date = new Date(parseInt(year), month, parseInt(day));
                        date.setHours(0, 0, 0, 0);
                        return date;
                    }
                }
                const parsed = new Date(dateStr);
                if (!isNaN(parsed.getTime())) {
                    parsed.setHours(0, 0, 0, 0);
                    return parsed;
                }
                return null;
            } catch (e) { return null; }
        }

        /**
         * Lane SLA lookup: origin_city × destination_city → expected days.
         *
         * IMPORTANT: When an EDD is present we derive lane SLA from:
         *   tat_expected = max(EDD.date - pickup.date, 0)
         * so that anything delivered on/before EDD is not TAT‑breached.
         * Only when EDD is missing do we fall back to a coarse lane table.
         */
        const LANE_SLA_DEFAULT_DAYS = 7; // conservative default so we don't over‑flag breaches
        const LANE_SLA_TABLE = {
            // Example overrides (can be tuned per business requirements):
            // 'bengaluru|bengaluru': 1,
            // 'bengaluru|hyderabad': 2,
            // 'delhi|mumbai': 2,
        };

        function laneSlaDays(originCity, destinationCity, pickupDate, eddDate) {
            // If we have both pickup and EDD, use them to derive SLA so EDD drives expectations.
            if (pickupDate && eddDate) {
                const pd = new Date(pickupDate.getTime());
                pd.setHours(0, 0, 0, 0);
                const ed = new Date(eddDate.getTime());
                ed.setHours(0, 0, 0, 0);
                const diffDays = Math.max(0, Math.floor((ed - pd) / (1000 * 60 * 60 * 24)));
                // Minimum 1 day if diff is zero, so same‑day EDD is treated as 1‑day SLA
                return diffDays || 1;
            }

            const key = `${String(originCity || '').toLowerCase()}|${String(destinationCity || '').toLowerCase()}`;
            return LANE_SLA_TABLE[key] ?? LANE_SLA_DEFAULT_DAYS;
        }

        /**
         * Normalize status codes to internal categories
         */
        function normalizeStatusCode(code) {
            const c = (code || '').toUpperCase();
            // Already-normalized values (common when importing from Excel exports)
            // IMPORTANT: do NOT treat "DDL" as a final code here; we want to
            // normalize it to "DELIVERED" below so all delivered logic is consistent.
            if (['DELIVERED', 'OFD', 'INTRANSIT', 'RTO', 'NDR', 'CANCELLED', 'LOST', 'UD', 'SAL', 'DAMAGED', 'OTHER'].includes(c)) return c;

            // Common description words
            if (c.includes('DELIVERED')) return 'DELIVERED';
            if (c.includes('OUT') && c.includes('DELIVERY')) return 'OFD';
            if (c.includes('IN') && c.includes('TRANSIT')) return 'INTRANSIT';
            if (c.includes('CANCEL')) return 'CANCELLED';
            if (c.includes('LOST')) return 'LOST';
            if (c.includes('RTO') || c.includes('RETURN')) return 'RTO';
            if (c.includes('NDR') || c.includes('UNDELIVER')) return 'NDR';

            if (c === 'DDL') return 'DELIVERED';
            if (c === 'OFD' || c === 'DDS') return 'OFD';
            if (['MAN', 'PKD', 'IND', 'BGD', 'DPD', 'ARD', 'RDC', 'DBG'].includes(c)) return 'INTRANSIT';
            if (c === 'RTO' || c.startsWith('RTO')) return 'RTO';
            if (c === 'UDD' || c === 'NDR') return 'NDR';
            if (c === 'CAN' || c === 'CANCELLED') return 'CANCELLED';
            if (c === 'LOST') return 'LOST';
            return 'OTHER';
        }

        // =====================================================
        // FILTERS
        // =====================================================
        function applyFilters() {
            applyFiltersAndRender();
        }

        function clearFilters() {
            document.getElementById('dateFilter').value = '';
            document.getElementById('typeFilter').value = 'ALL';
            document.getElementById('statusFilter').value = 'ALL';
            document.getElementById('originFilter').value = 'ALL';
            document.getElementById('destinationFilter').value = 'ALL';
            const tableSearch = document.getElementById('tableSearchInput');
            if (tableSearch) tableSearch.value = '';
            const quickCustomer = document.getElementById('quickCustomerFilter');
            if (quickCustomer) quickCustomer.value = '';
            const quickDate = document.getElementById('quickDateFilter');
            if (quickDate) quickDate.value = '';
            
            // Reset quick type chips
            document.querySelectorAll('.type-chip').forEach(btn => {
                if (btn.dataset.type === 'ALL') {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Reset status chips
            setStatusFilter('ALL');
            applyFiltersAndRender();
        }

        function setStatusFilter(status) {
            document.getElementById('statusFilter').value = status;
            
            // Update chip active states
            document.querySelectorAll('.status-chip').forEach(chip => {
                if (chip.dataset.status === status) {
                    chip.classList.add('active');
                } else {
                    chip.classList.remove('active');
                }
            });
            
            applyFiltersAndRender();
        }

        function setTypeQuickFilter(type) {
            const select = document.getElementById('typeFilter');
            if (select) {
                select.value = type;
            }
            document.querySelectorAll('.type-chip').forEach(btn => {
                if (btn.dataset.type === type) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            applyFiltersAndRender();
        }

        function onQuickCustomerFilterChange() {
            const quick = document.getElementById('quickCustomerFilter');
            const tableSearch = document.getElementById('tableSearchInput');
            if (quick && tableSearch) {
                tableSearch.value = quick.value || '';
            }
            applyFiltersAndRender();
        }

        function onQuickDateFilterChange() {
            const quick = document.getElementById('quickDateFilter');
            const hidden = document.getElementById('dateFilter');
            if (quick && hidden) {
                hidden.value = quick.value || '';
            }
            applyFiltersAndRender();
        }

        function updateFilterDropdowns() {
            // Get unique origins and destinations from current shipments
            const origins = new Set();
            const destinations = new Set();
            
            State.shipments.forEach(s => {
                if (s.origin) origins.add(s.origin);
                if (s.destination) destinations.add(s.destination);
            });
            
            // Update origin dropdown
            const originSelect = document.getElementById('originFilter');
            const currentOrigin = originSelect.value;
            originSelect.innerHTML = '<option value="ALL">All Origins</option>';
            [...origins].sort().forEach(origin => {
                originSelect.innerHTML += `<option value="${escapeHtml(origin)}">${escapeHtml(origin)}</option>`;
            });
            originSelect.value = currentOrigin || 'ALL';
            
            // Update destination dropdown
            const destSelect = document.getElementById('destinationFilter');
            const currentDest = destSelect.value;
            destSelect.innerHTML = '<option value="ALL">All Destinations</option>';
            [...destinations].sort().forEach(dest => {
                destSelect.innerHTML += `<option value="${escapeHtml(dest)}">${escapeHtml(dest)}</option>`;
            });
            destSelect.value = currentDest || 'ALL';
        }

        function updateActiveFilterCount() {
            let count = 0;
            if (document.getElementById('statusFilter').value !== 'ALL') count++;
            if (document.getElementById('typeFilter').value !== 'ALL') count++;
            if (document.getElementById('originFilter').value !== 'ALL') count++;
            if (document.getElementById('destinationFilter').value !== 'ALL') count++;
            const tableSearch = document.getElementById('tableSearchInput');
            if (tableSearch && tableSearch.value.trim()) count++;
            
            const badge = document.getElementById('activeFilterCount');
            if (count > 0) {
                badge.textContent = `${count} filter${count > 1 ? 's' : ''} active`;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }

        function applyFiltersAndRender() {
            const typeFilter = document.getElementById('typeFilter').value;
            const statusFilter = document.getElementById('statusFilter').value;
            const originFilter = document.getElementById('originFilter').value;
            const destinationFilter = document.getElementById('destinationFilter').value;
            const tableSearch = document.getElementById('tableSearchInput');
            const searchTerm = tableSearch ? tableSearch.value.toLowerCase().trim() : '';
            const dateFilter = document.getElementById('dateFilter').value;

            State.filteredShipments = State.shipments.filter(s => {
                // Type filter
                if (typeFilter !== 'ALL' && s.type !== typeFilter) return false;
                
                // Special status filters
                if (statusFilter === 'FAILURE') {
                    // Failure bucket: delayed OR lifecycle breach OR RTO/Cancelled/NDR
                    if (!s.isInFailureBucket) return false;
                } else if (statusFilter === 'DELAYED') {
                    // Only delayed shipments (negative delay days)
                    if (!s.isDelayed) return false;
                } else if (statusFilter !== 'ALL') {
                    // Normal status filter (with special handling for Delivered)
                    if (statusFilter === 'DELIVERED') {
                        const ts = s.terminalStatus ? String(s.terminalStatus).toLowerCase() : '';
                        if (ts) {
                            if (ts !== 'delivered') return false;
                        } else if (s.statusCode !== 'DELIVERED') {
                            return false;
                        }
                    } else {
                        if (s.statusCode !== statusFilter) return false;
                    }
                }
                
                // Date filter (by pickup/addedOn date)
                if (dateFilter) {
                    const pickup = parseApiDate(s.addedOn);
                    const filterDate = parseApiDate(dateFilter);
                    if (!pickup || !filterDate || pickup.getTime() !== filterDate.getTime()) {
                        return false;
                    }
                }
                
                // Origin filter
                if (originFilter !== 'ALL' && s.origin !== originFilter) return false;
                
                // Destination filter
                if (destinationFilter !== 'ALL' && s.destination !== destinationFilter) return false;
                
                // Text search
                if (searchTerm) {
                    const searchFields = [
                        s.awb,
                        s.customer,
                        s.origin,
                        s.destination,
                        s.currentLocation,
                        s.status,
                        s.orderNumber,
                        ...(s.failureReasons || [])
                    ].filter(Boolean).map(f => String(f).toLowerCase());
                    
                    if (!searchFields.some(field => field.includes(searchTerm))) {
                        return false;
                    }
                }
                
                return true;
            });

            // Sort by AWB in numeric series (no delay-based sorting)
            State.filteredShipments.sort((a, b) => {
                const aNum = parseInt(a.awb, 10);
                const bNum = parseInt(b.awb, 10);

                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }

                // Fallback to string compare if not purely numeric
                return String(a.awb).localeCompare(String(b.awb));
            });

            State.currentPage = 1;
            updateActiveFilterCount();
            updateFailureBucketAlert();
            if (State.insightsPanelOpen) renderInsightsPanel(computeInsights(State.shipments));
            renderKPIs();
            renderTable();
        }

        /**
         * Update the failure bucket alert banner
         */
        function updateFailureBucketAlert() {
            const failures = State.shipments.filter(s => s.isInFailureBucket);
            const alertEl = document.getElementById('failureBucketAlert');
            const countEl = document.getElementById('failureBucketCount');
            const scopeEl = document.getElementById('failureBucketScope');
            const detailsEl = document.getElementById('failureBucketDetails');
            const chipCountEl = document.getElementById('failureChipCount');
            const onThisPage = State.serverPagination && State.serverPagination.pages && State.serverPagination.pages.length > 0;
            if (scopeEl) scopeEl.textContent = onThisPage ? ' (on this page)' : '';
            if (scopeEl) scopeEl.style.fontWeight = 'normal';

            if (failures.length > 0) {
                // Count by reason
                const delayed = failures.filter(s => s.isDelayed).length;
                const breaches = failures.filter(s => s.lifecycleBreach).length;
                const rto = failures.filter(s => s.statusCode === 'RTO').length;
                const ndr = failures.filter(s => s.statusCode === 'NDR').length;
                
                const details = [];
                if (delayed > 0) details.push(`${delayed} delayed`);
                if (breaches > 0) details.push(`${breaches} lifecycle breach`);
                if (rto > 0) details.push(`${rto} RTO`);
                if (ndr > 0) details.push(`${ndr} NDR`);
                
                countEl.textContent = failures.length;
                detailsEl.textContent = details.join(', ');
                alertEl.classList.remove('hidden');
                
                // Update chip count
                chipCountEl.textContent = failures.length;
                chipCountEl.classList.remove('hidden');
            } else {
                alertEl.classList.add('hidden');
                chipCountEl.classList.add('hidden');
            }
        }

        function dismissFailureAlert() {
            document.getElementById('failureBucketAlert').classList.add('hidden');
        }

        /**
         * Compute insights from shipment data (patterns not visible directly in the table).
         */
        function computeInsights(shipments) {
            if (!Array.isArray(shipments) || shipments.length === 0) {
                return { empty: true };
            }
            const total = shipments.length;

            // Delivered: terminalStatus delivered or statusCode DELIVERED
            const isDelivered = (s) => (s.terminalStatus && String(s.terminalStatus).toLowerCase() === 'delivered') || s.statusCode === 'DELIVERED';
            const delivered = shipments.filter(isDelivered);
            const delayed = shipments.filter(s => s.isDelayed === true);
            const rto = shipments.filter(s => s.statusCode === 'RTO' || (s.terminalStatus && String(s.terminalStatus).toLowerCase() === 'rto'));

            // Top delayed customers (by count)
            const delayedByCustomer = {};
            delayed.forEach(s => {
                const c = (s.customer || 'N/A').trim();
                delayedByCustomer[c] = (delayedByCustomer[c] || 0) + 1;
            });
            const topDelayedCustomers = Object.entries(delayedByCustomer)
                .map(([name, count]) => ({ name, count, pct: total ? ((count / total) * 100).toFixed(1) : 0 }))
                .sort((a, b) => b.count - a.count)
                .slice(0, 5);

            // RTO rate by customer
            const byCustomer = {};
            shipments.forEach(s => {
                const c = (s.customer || 'N/A').trim();
                if (!byCustomer[c]) byCustomer[c] = { total: 0, rto: 0 };
                byCustomer[c].total++;
                if (s.statusCode === 'RTO' || (s.terminalStatus && String(s.terminalStatus).toLowerCase() === 'rto')) byCustomer[c].rto++;
            });
            const rtoByCustomer = Object.entries(byCustomer)
                .filter(([, v]) => v.total >= 3)
                .map(([name, v]) => ({ name, total: v.total, rto: v.rto, pct: v.total ? ((v.rto / v.total) * 100).toFixed(1) : 0 }))
                .sort((a, b) => parseFloat(b.pct) - parseFloat(a.pct))
                .slice(0, 5);

            // Status distribution
            const statusCounts = {};
            shipments.forEach(s => {
                const code = s.statusCode || 'Unknown';
                statusCounts[code] = (statusCounts[code] || 0) + 1;
            });
            const statusDistribution = Object.entries(statusCounts)
                .map(([code, count]) => ({ code, count, pct: total ? ((count / total) * 100).toFixed(1) : 0 }))
                .sort((a, b) => b.count - a.count);

            // Most common delay / failure reasons (reasonCode or reasonDescription)
            const reasonCounts = {};
            [...delayed, ...rto].forEach(s => {
                const r = (s.reasonCode || s.reasonDescription || (s.failureReasons && s.failureReasons[0]) || 'Unknown').toString().trim();
                if (!r) return;
                reasonCounts[r] = (reasonCounts[r] || 0) + 1;
            });
            const topReasons = Object.entries(reasonCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([reason, count]) => ({ reason, count }));

            // Hubs/lanes with most delays (origin or destination)
            const delayedByOrigin = {};
            const delayedByDest = {};
            delayed.forEach(s => {
                const o = (s.origin || 'N/A').trim();
                const d = (s.destination || 'N/A').trim();
                delayedByOrigin[o] = (delayedByOrigin[o] || 0) + 1;
                delayedByDest[d] = (delayedByDest[d] || 0) + 1;
            });
            const worstOrigins = Object.entries(delayedByOrigin).sort((a, b) => b[1] - a[1]).slice(0, 3);
            const worstDestinations = Object.entries(delayedByDest).sort((a, b) => b[1] - a[1]).slice(0, 3);

            // Peak day of week (by last update / activity) + full week for chart
            const dayCounts = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0 };
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            shipments.forEach(s => {
                const d = parseApiDate(s.lastUpdate) || parseApiDate(s.addedOn);
                if (d) dayCounts[d.getDay()]++;
            });
            const peakDay = Object.entries(dayCounts).sort((a, b) => b[1] - a[1])[0];
            const peakDayOfWeek = peakDay ? { day: dayNames[parseInt(peakDay[0], 10)], count: peakDay[1] } : null;
            const dayDistribution = dayNames.map((day, i) => ({ day, count: dayCounts[i] || 0 }));

            // Average TAT (delivered) when available
            const tatValues = delivered.filter(s => s.tatActualDays != null && !isNaN(s.tatActualDays)).map(s => Number(s.tatActualDays));
            const avgTatDays = tatValues.length ? (tatValues.reduce((a, b) => a + b, 0) / tatValues.length).toFixed(1) : null;

            // Bottleneck: average days in each stage (when we have scans with timestamps)
            let avgPkdToOfdDays = null;
            let avgOfdToDdlDays = null;
            const pkdOfdDiffs = [];
            const ofdDdlDiffs = [];
            shipments.forEach(s => {
                const scans = (s.scans || []).slice();
                if (scans.length < 2) return;
                const getTs = (scan) => {
                    const t = scan.statusDateTime && parseApiDate(scan.statusDateTime);
                    return t ? t.getTime() : null;
                };
                const pkd = scans.find(sc => (sc.statusCode || '').toUpperCase() === 'PKD');
                const ofd = scans.find(sc => (sc.statusCode || '').toUpperCase() === 'OFD');
                const ddl = scans.find(sc => (sc.statusCode || '').toUpperCase() === 'DDL');
                const tsPkd = pkd && getTs(pkd);
                const tsOfd = ofd && getTs(ofd);
                const tsDdl = ddl && getTs(ddl);
                if (tsPkd && tsOfd) pkdOfdDiffs.push((tsOfd - tsPkd) / (1000 * 60 * 60 * 24));
                if (tsOfd && tsDdl) ofdDdlDiffs.push((tsDdl - tsOfd) / (1000 * 60 * 60 * 24));
            });
            if (pkdOfdDiffs.length) avgPkdToOfdDays = (pkdOfdDiffs.reduce((a, b) => a + b, 0) / pkdOfdDiffs.length).toFixed(1);
            if (ofdDdlDiffs.length) avgOfdToDdlDays = (ofdDdlDiffs.reduce((a, b) => a + b, 0) / ofdDdlDiffs.length).toFixed(1);

            // Regional delivery performance (by destination): on-time % and RTO % per region
            const isDeliveredRowR = (s) => (s.terminalStatus && String(s.terminalStatus).toLowerCase() === 'delivered') || s.statusCode === 'DELIVERED';
            const isOnTimeR = (s) => { if (!isDeliveredRowR(s)) return false; if (s.delayedDays !== null && s.delayedDays !== undefined) return s.delayedDays >= 0; return true; };
            const byRegion = {};
            shipments.forEach(s => {
                const region = (s.destination || 'N/A').trim();
                if (!byRegion[region]) byRegion[region] = { total: 0, delivered: 0, onTime: 0, rto: 0 };
                byRegion[region].total++;
                if (isDeliveredRowR(s)) { byRegion[region].delivered++; if (isOnTimeR(s)) byRegion[region].onTime++; }
                else if (s.statusCode === 'RTO' || (s.terminalStatus && String(s.terminalStatus).toLowerCase() === 'rto')) byRegion[region].rto++;
            });
            const regionalPerformance = Object.entries(byRegion)
                .filter(([, v]) => v.total >= 10)
                .map(([region, v]) => ({ region, total: v.total, onTimePct: v.delivered ? ((v.onTime / v.delivered) * 100).toFixed(1) : '0', rtoPct: v.total ? ((v.rto / v.total) * 100).toFixed(1) : '0' }))
                .sort((a, b) => parseFloat(b.onTimePct) - parseFloat(a.onTimePct))
                .slice(0, 10);

            return {
                empty: false,
                total,
                delivered: delivered.length,
                delayed: delayed.length,
                rto: rto.length,
                topDelayedCustomers,
                rtoByCustomer,
                statusDistribution,
                topReasons,
                worstOrigins,
                worstDestinations,
                peakDayOfWeek,
                dayDistribution,
                regionalPerformance,
                avgTatDays,
                avgPkdToOfdDays,
                avgOfdToDdlDays,
            };
        }

        function toggleInsightsPanel() {
            State.insightsPanelOpen = !State.insightsPanelOpen;
            const panel = document.getElementById('insightsPanel');
            const chevron = document.getElementById('insightsChevron');
            if (panel) {
                panel.classList.toggle('hidden', !State.insightsPanelOpen);
                if (State.insightsPanelOpen) {
                    renderInsightsPanel(computeInsights(State.shipments));
                    const section = document.getElementById('insightsSection');
                    if (section) section.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
            if (chevron) chevron.style.transform = State.insightsPanelOpen ? 'rotate(180deg)' : 'none';
        }

        // Professional palette: teal/success, coral/danger, amber/warning, indigo/slate for neutrals
        const CHART_COLORS = {
            delayed: ['#0d9488','#0f766e','#115e59','#134e4a','#042f2e'],      // teal
            rto: ['#e11d48','#be123c','#9f1239','#881337','#4c0519'],         // rose
            status: ['#0d9488','#6366f1','#64748b','#f59e0b','#e11d48','#94a3b8','#475569','#334155','#0f172a'],
            reasons: ['#ea580c','#c2410c','#9a3412','#7c2d12','#431407'],      // orange
            hubs: ['#7c3aed','#6d28d9','#5b21b6','#4c1d95','#3730a3','#312e81'],
            day: ['#0d9488','#14b8a6','#2dd4bf','#5eead4','#99f6e4','#ccfbf1','#f0fdfa'],
            regionGood: '#059669',
            regionBad: '#dc2626',
            regionMid: '#d97706',
        };
        const chartDefaults = { responsive: true, maintainAspectRatio: true, plugins: { legend: { display: false }, tooltip: { backgroundColor: '#0f172a', titleFont: { size: 12 }, bodyFont: { size: 11 }, padding: 10, cornerRadius: 8 } }, scales: { x: { grid: { display: false }, ticks: { font: { size: 10 }, color: '#64748b' } }, y: { grid: { color: '#f1f5f9' }, ticks: { font: { size: 10 }, color: '#475569' } } } };

        function renderInsightsPanel(insights) {
            const container = document.getElementById('insightsContent');
            if (!container) return;
            if (typeof window._insightsCharts !== 'undefined' && Array.isArray(window._insightsCharts)) { window._insightsCharts.forEach(c => { try { c.destroy(); } catch (_) {} }); }
            window._insightsCharts = [];
            if (insights.empty || !State.shipments.length) {
                container.innerHTML = '<p class="text-sm text-slate-500 col-span-full self-center">Load shipment data first to see insights.</p>';
                return;
            }
            const fromCurrentPage = State.serverPagination && State.serverPagination.pages && State.serverPagination.pages.length > 0;
            const { topDelayedCustomers, rtoByCustomer, statusDistribution, topReasons, worstOrigins, worstDestinations, dayDistribution, regionalPerformance, avgTatDays, avgPkdToOfdDays, avgOfdToDdlDays } = insights;
            const cards = [];
            const truncate = (s, len) => (s.length <= len ? s : s.slice(0, len) + '\u2026');
            if (fromCurrentPage) cards.push(`<div class="insight-card col-span-full bg-amber-50 border border-amber-200 rounded-xl p-3 flex-shrink-0"><p class="text-xs text-amber-800"><strong>Note:</strong> Charts below are based on the current page of shipments (${State.shipments.length} rows), not the full database.</p></div>`);

            if (regionalPerformance && regionalPerformance.length > 0) cards.push(`<div class="insight-card bg-white border border-slate-200 rounded-xl p-4 premium-shadow flex-shrink-0"><h4 class="text-xs font-bold text-teal-800 uppercase tracking-wide mb-3">Regional delivery performance</h4><p class="text-[10px] text-slate-500 mb-2">On-time % by destination (min 10 shipments)</p><div class="h-56"><canvas id="insightChartRegion"></canvas></div><p class="text-[9px] text-slate-400 mt-2 flex items-center gap-3"><span><span class="inline-block w-2 h-2 rounded-full bg-emerald-500"></span> Good (≥80%)</span><span><span class="inline-block w-2 h-2 rounded-full bg-amber-500"></span> Mid (50–80%)</span><span><span class="inline-block w-2 h-2 rounded-full bg-rose-500"></span> Poor (&lt;50%)</span></p></div>`);
            if (topDelayedCustomers.length > 0) cards.push(`<div class="insight-card bg-white border border-slate-200 rounded-xl p-4 premium-shadow flex-shrink-0"><h4 class="text-xs font-bold text-amber-800 uppercase tracking-wide mb-3">Top delayed customers</h4><div class="h-48"><canvas id="insightChartDelayed"></canvas></div></div>`);
            if (rtoByCustomer.length > 0) cards.push(`<div class="insight-card bg-white border border-slate-200 rounded-xl p-4 premium-shadow flex-shrink-0"><h4 class="text-xs font-bold text-rose-800 uppercase tracking-wide mb-3">RTO rate by customer</h4><div class="h-48"><canvas id="insightChartRto"></canvas></div></div>`);
            if (statusDistribution.length > 0) cards.push(`<div class="insight-card bg-white border border-slate-200 rounded-xl p-4 premium-shadow flex-shrink-0"><h4 class="text-xs font-bold text-slate-800 uppercase tracking-wide mb-3">Status mix</h4><div class="h-52 flex items-center justify-center"><canvas id="insightChartStatus"></canvas></div></div>`);
            if (topReasons.length > 0) cards.push(`<div class="insight-card bg-white border border-slate-200 rounded-xl p-4 premium-shadow flex-shrink-0"><h4 class="text-xs font-bold text-orange-800 uppercase tracking-wide mb-3">Delay / failure reasons</h4><div class="h-48"><canvas id="insightChartReasons"></canvas></div></div>`);
            if (worstOrigins.length > 0 || worstDestinations.length > 0) {
                const hubLabels = [...worstOrigins.map(([h]) => truncate(h, 14) + ' (Origin)'), ...worstDestinations.map(([h]) => truncate(h, 14) + ' (Dest)')];
                const hubValues = [...worstOrigins.map(([, n]) => n), ...worstDestinations.map(([, n]) => n)];
                cards.push(`<div class="insight-card bg-white border border-slate-200 rounded-xl p-4 premium-shadow flex-shrink-0"><h4 class="text-xs font-bold text-violet-800 uppercase tracking-wide mb-3">Hubs with most delays</h4><p class="text-[10px] text-slate-500 mb-1">Delays by origin / destination hub</p><div class="h-40"><canvas id="insightChartHubs"></canvas></div></div>`);
                window._insightsHubData = { labels: hubLabels, values: hubValues };
            }
            if (dayDistribution && dayDistribution.length > 0) cards.push(`<div class="insight-card bg-white border border-slate-200 rounded-xl p-4 premium-shadow flex-shrink-0"><h4 class="text-xs font-bold text-emerald-800 uppercase tracking-wide mb-3">Activity by day</h4><div class="h-48"><canvas id="insightChartPeak"></canvas></div></div>`);
            if (avgTatDays != null) cards.push(`<div class="insight-card bg-white border border-slate-200 rounded-xl p-4 premium-shadow flex-shrink-0 flex flex-col justify-center"><h4 class="text-xs font-bold text-blue-800 uppercase tracking-wide mb-1">Avg delivery TAT</h4><p class="text-2xl font-bold text-blue-600">${escapeHtml(avgTatDays)} <span class="text-sm font-normal text-slate-500">days</span></p><p class="text-[10px] text-slate-400 mt-1">Delivered only</p></div>`);
            if (avgPkdToOfdDays != null || avgOfdToDdlDays != null) cards.push(`<div class="insight-card bg-white border border-slate-200 rounded-xl p-4 premium-shadow flex-shrink-0 flex flex-col justify-center"><h4 class="text-xs font-bold text-indigo-800 uppercase tracking-wide mb-2">Avg stage duration</h4><p class="text-sm text-slate-700">PKD → OFD: <strong>${avgPkdToOfdDays != null ? escapeHtml(avgPkdToOfdDays) : '—'} days</strong></p><p class="text-sm text-slate-700 mt-1">OFD → DDL: <strong>${avgOfdToDdlDays != null ? escapeHtml(avgOfdToDdlDays) : '—'} days</strong></p></div>`);

            container.innerHTML = cards.length ? cards.join('') : '<p class="text-sm text-slate-500 col-span-full">No derived insights yet.</p>';

            if (typeof Chart === 'undefined') return;
            if (regionalPerformance && regionalPerformance.length > 0) {
                const ctx = document.getElementById('insightChartRegion');
                if (ctx) {
                    const onTimePcts = regionalPerformance.map(r => parseFloat(r.onTimePct));
                    const regionColors = onTimePcts.map(p => p >= 80 ? CHART_COLORS.regionGood : p >= 50 ? CHART_COLORS.regionMid : CHART_COLORS.regionBad);
                    const rp = regionalPerformance;
                    const ch = new Chart(ctx.getContext('2d'), {
                        type: 'bar',
                        data: {
                            labels: regionalPerformance.map(r => truncate(r.region, 14)),
                            datasets: [{ label: 'On-time %', data: onTimePcts, backgroundColor: regionColors, borderWidth: 0 }],
                        },
                        options: {
                            ...chartDefaults,
                            indexAxis: 'y',
                            scales: { ...chartDefaults.scales, x: { ...chartDefaults.scales.x, beginAtZero: true, max: 100 } },
                            plugins: {
                                ...chartDefaults.plugins,
                                tooltip: {
                                    ...chartDefaults.plugins.tooltip,
                                    callbacks: {
                                        afterLabel: function(ctx) {
                                            const i = ctx.dataIndex;
                                            if (rp[i]) return 'RTO: ' + rp[i].rtoPct + '%  |  Total: ' + rp[i].total;
                                            return '';
                                        },
                                    },
                                },
                            },
                        },
                    });
                    window._insightsCharts.push(ch);
                }
            }
            if (topDelayedCustomers.length > 0) {
                const ctx = document.getElementById('insightChartDelayed');
                if (ctx) { const ch = new Chart(ctx.getContext('2d'), { type: 'bar', data: { labels: topDelayedCustomers.map(c => truncate(c.name, 20)), datasets: [{ label: 'Delayed', data: topDelayedCustomers.map(c => c.count), backgroundColor: CHART_COLORS.delayed }] }, options: { ...chartDefaults, indexAxis: 'y', scales: { ...chartDefaults.scales, x: { ...chartDefaults.scales.x, title: { display: true, text: 'Delayed count' }, beginAtZero: true } } } }); window._insightsCharts.push(ch); }
            }
            if (rtoByCustomer.length > 0) {
                const ctx = document.getElementById('insightChartRto');
                if (ctx) { const ch = new Chart(ctx.getContext('2d'), { type: 'bar', data: { labels: rtoByCustomer.map(c => truncate(c.name, 20)), datasets: [{ label: 'RTO %', data: rtoByCustomer.map(c => parseFloat(c.pct)), backgroundColor: CHART_COLORS.rto }] }, options: { ...chartDefaults, indexAxis: 'y', scales: { ...chartDefaults.scales, x: { ...chartDefaults.scales.x, title: { display: true, text: 'RTO %' }, beginAtZero: true, max: 100 } } } }); window._insightsCharts.push(ch); }
            }
            if (statusDistribution.length > 0) {
                const ctx = document.getElementById('insightChartStatus');
                if (ctx) { const ch = new Chart(ctx.getContext('2d'), { type: 'doughnut', data: { labels: statusDistribution.map(s => s.code), datasets: [{ data: statusDistribution.map(s => s.count), backgroundColor: CHART_COLORS.status }] }, options: { responsive: true, maintainAspectRatio: true, plugins: { legend: { position: 'bottom', labels: { font: { size: 10 }, padding: 8 } }, tooltip: chartDefaults.plugins.tooltip } } }); window._insightsCharts.push(ch); }
            }
            if (topReasons.length > 0) {
                const ctx = document.getElementById('insightChartReasons');
                const reasonLabels = topReasons.map(r => truncate(r.reason, 22));
                const reasonFull = topReasons.map(r => r.reason);
                if (ctx) {
                    const ch = new Chart(ctx.getContext('2d'), {
                        type: 'bar',
                        data: { labels: reasonLabels, datasets: [{ label: 'Count', data: topReasons.map(r => r.count), backgroundColor: CHART_COLORS.reasons }] },
                        options: {
                            ...chartDefaults,
                            indexAxis: 'y',
                            scales: { ...chartDefaults.scales, x: { ...chartDefaults.scales.x, title: { display: true, text: 'Count' }, beginAtZero: true } },
                            plugins: { ...chartDefaults.plugins, tooltip: { ...chartDefaults.plugins.tooltip, callbacks: { title: function(ctx) { const i = ctx[0].dataIndex; return reasonFull[i] != null ? reasonFull[i] : ctx[0].label; } } } },
                        },
                    });
                    window._insightsCharts.push(ch);
                }
            }
            if (window._insightsHubData) {
                const ctx = document.getElementById('insightChartHubs');
                const hubLabels = window._insightsHubData.labels;
                const hubValues = window._insightsHubData.values;
                if (ctx) {
                    const ch = new Chart(ctx.getContext('2d'), {
                        type: 'bar',
                        data: { labels: hubLabels, datasets: [{ label: 'Delays', data: hubValues, backgroundColor: CHART_COLORS.hubs }] },
                        options: {
                            ...chartDefaults,
                            indexAxis: 'y',
                            scales: { ...chartDefaults.scales, x: { ...chartDefaults.scales.x, title: { display: true, text: 'Number of delays' }, beginAtZero: true } },
                            plugins: { ...chartDefaults.plugins, tooltip: { ...chartDefaults.plugins.tooltip, callbacks: { afterLabel: function(ctx) { return 'Delays: ' + (hubValues[ctx.dataIndex] ?? ctx.parsed.x); } } } },
                        },
                    });
                    window._insightsCharts.push(ch);
                }
                window._insightsHubData = null;
            }
            if (dayDistribution && dayDistribution.length > 0) {
                const ctx = document.getElementById('insightChartPeak');
                if (ctx) { const ch = new Chart(ctx.getContext('2d'), { type: 'bar', data: { labels: dayDistribution.map(d => d.day), datasets: [{ label: 'Shipments', data: dayDistribution.map(d => d.count), backgroundColor: CHART_COLORS.day }] }, options: { ...chartDefaults, indexAxis: 'x', scales: { ...chartDefaults.scales, y: { ...chartDefaults.scales.y, beginAtZero: true } } } }); window._insightsCharts.push(ch); }
            }
        }

        /**
         * Parse date strings from API format: "07 Jul 2025, 14:39" or "21 Nov 2025, 13:19"
         * Returns timestamp for sorting
         */
        function parseShipmentDate(dateStr) {
            if (!dateStr) return 0;
            
            try {
                // Format: "DD MMM YYYY, HH:MM"
                const months = {
                    'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5,
                    'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11
                };
                
                // Parse "07 Jul 2025, 14:39"
                const match = dateStr.match(/(\d{1,2})\s+(\w{3})\s+(\d{4}),?\s*(\d{1,2}):(\d{2})/);
                if (match) {
                    const [, day, monthStr, year, hour, minute] = match;
                    const month = months[monthStr];
                    if (month !== undefined) {
                        return new Date(parseInt(year), month, parseInt(day), parseInt(hour), parseInt(minute)).getTime();
                    }
                }
                
                // Fallback: try native Date parsing
                const parsed = new Date(dateStr);
                return isNaN(parsed.getTime()) ? 0 : parsed.getTime();
            } catch (e) {
                return 0;
            }
        }

        // =====================================================
        // RENDER KPIs
        // =====================================================
        function renderKPIs() {
            const data = State.filteredShipments;
            const total = data.length;
            // Helper: Delivered = explicit delivered terminal status,
            // or (only when terminalStatus is absent) a DELIVERED status code.
            const isDeliveredRow = (s) => {
                const ts = s.terminalStatus ? String(s.terminalStatus).toLowerCase() : '';
                if (ts) {
                    // If we know the terminal_status, trust it and ONLY count true "delivered"
                    return ts === 'delivered';
                }
                // Fallback when terminal_status is not provided
                return s.statusCode === 'DELIVERED';
            };

            // Helper: business on-time rule
            // - Must be delivered
            // - If we have delivery + EDD dates: on-time when deliveryDate <= eddDate
            //   (earlier deliveries also on time)
            // - If EDD is missing but delayedDays is available: delayedDays >= 0 means on-time
            // - If neither is available, treat delivered as on-time (we can't prove it's late)
            const isOnTimeDelivery = (s) => {
                if (!isDeliveredRow(s)) return false;

                const deliveredAt = s.deliveredAt;
                const eddDate = s.eddDate || (s.edd ? parseApiDate(s.edd) : null);

                if (deliveredAt && eddDate) {
                    const d = new Date(deliveredAt);
                    d.setHours(0, 0, 0, 0);
                    const e = new Date(eddDate);
                    e.setHours(0, 0, 0, 0);
                    // On-time if delivered on or before EDD; earlier deliveries are also on time
                    return d.getTime() <= e.getTime();
                }

                if (s.delayedDays !== null && s.delayedDays !== undefined) {
                    return s.delayedDays >= 0;
                }

                // No EDD / delay info: count delivered as on-time by default
                return true;
            };

            const delivered = data.filter(isDeliveredRow).length;
            const inTransit = data.filter(s => ['INTRANSIT', 'OFD'].includes(s.statusCode)).length;
            const exceptions = data.filter(s => ['RTO', 'NDR', 'CANCELLED'].includes(s.statusCode)).length;
            const codValue = data.filter(s => s.type === 'COD').reduce((sum, s) => sum + (s.value || 0), 0);
            
            // SLA Metrics:
            // - Delivered counter: all delivered shipments, regardless of SLA
            // - On-time SLA: apply business rule above
            const onTimeDeliveries = data.filter(isOnTimeDelivery).length;
            const onTimeRate = delivered > 0 ? Math.round((onTimeDeliveries / delivered) * 100) : 0;
            const delayedCount = delivered - onTimeDeliveries;
            const breachCount = 0; // breach logic disabled for now
            
            // Calculate average delay (only for delayed shipments)
            const delayedShipments = data.filter(s => s.delayedDays !== null && s.delayedDays < 0);
            const avgDelay = delayedShipments.length > 0 
                ? Math.round(delayedShipments.reduce((sum, s) => sum + Math.abs(s.delayedDays), 0) / delayedShipments.length)
                : 0;

            // When using server-side pagination, KPIs are driven by the summary API (full DB) — don't overwrite with current-page counts
            const kpisFromSummary = State.serverPagination && State.serverPagination.pages && State.serverPagination.pages.length > 0;
            if (!kpisFromSummary) {
                // Primary KPIs
                document.getElementById('kpi-total').textContent = total.toLocaleString();
                document.getElementById('kpi-delivered').textContent = delivered.toLocaleString();
                document.getElementById('kpi-intransit').textContent = inTransit.toLocaleString();
                document.getElementById('kpi-exceptions').textContent = exceptions.toLocaleString();
                // SLA KPIs
                document.getElementById('kpi-dsr').textContent = onTimeRate + '%';
                document.getElementById('kpi-delayed').textContent = delayedCount.toLocaleString();
                document.getElementById('kpi-breach').textContent = breachCount.toLocaleString();
                document.getElementById('kpi-cod').textContent = '₹' + codValue.toLocaleString('en-IN');
                document.getElementById('kpi-avgdelay').textContent = avgDelay > 0 ? `-${avgDelay} days` : '-- days';
                // Exception badge
                const badge = document.getElementById('exceptionBadge');
                if (exceptions > 0) {
                    badge.textContent = exceptions;
                    badge.classList.remove('hidden');
                } else {
                    badge.classList.add('hidden');
                }
            }
        }

        // =====================================================
        // RENDER TABLE
        // =====================================================
        function renderTable() {
            const tbody = document.getElementById('resultsTable');
            const footer = document.getElementById('tableFooter');
            const subtitle = document.getElementById('resultsSubtitle');
            const data = State.filteredShipments;

            if (data.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" class="py-16 text-center">
                            <div class="flex flex-col items-center">
                                <iconify-icon icon="solar:magnifer-linear" width="48" class="text-slate-300 mb-3"></iconify-icon>
                                <p class="text-slate-500 font-medium">${State.shipments.length === 0 ? 'No shipments tracked yet' : 'No shipments match filters'}</p>
                                <p class="text-slate-400 text-xs mt-1">${State.shipments.length === 0 ? 'Enter an AWB number above to track a shipment' : 'Try adjusting your filters'}</p>
                        </div>
                        </td>
                    </tr>
                `;
                footer.classList.add('hidden');
                subtitle.textContent = 'Track AWBs to see results';
                return;
            }

            // Pagination
            const totalPages = Math.ceil(data.length / State.pageSize);
            const start = (State.currentPage - 1) * State.pageSize;
            const end = start + State.pageSize;
            const pageData = data.slice(start, end);

            tbody.innerHTML = pageData.map(s => {
                const statusClass = getStatusClass(s.statusCode);
                const rowClass = getLifecycleRowClass(s);
                const delayDisplay = formatDelayDays(s.delayedDays);
                const slaDisplay = formatSlaStatus(s);
                const eddDisplay = formatEdd(s.edd);
                const dcDisplay = s.currentLocation ? escapeHtml(s.currentLocation) : '--';
                const pickupDisplay = s.addedOn ? escapeHtml(s.addedOn) : '';
                
                return `
                <tr class="${rowClass} hover:bg-slate-50/50 cursor-pointer transition-colors" onclick="viewShipment('${escapeHtml(s.awb)}')">
                    <td class="py-3 px-4">
                        <a href="shipment.html?awb=${encodeURIComponent(s.awb)}" class="font-mono text-xs font-bold text-blue-600 hover:text-blue-800 hover:underline focus:outline-none focus:ring-2 focus:ring-blue-400 rounded" onclick="event.stopPropagation();" title="Open shipment detail (tracking history)">${escapeHtml(s.awb)}</a>
                        ${s.orderNumber ? `<div class="text-[10px] text-slate-400 mt-0.5">#${escapeHtml(s.orderNumber)}</div>` : ''}
                    </td>
                    <td class="py-3 px-4">
                        <div class="text-xs font-medium text-slate-900 truncate max-w-[150px]" title="${escapeHtml(s.customer)}">${escapeHtml(s.customer)}</div>
                    </td>
                    <td class="py-3 px-4 text-xs text-slate-900 font-medium">${dcDisplay}</td>
                    <td class="py-3 px-4 text-xs text-slate-600">
                        ${pickupDisplay || '<span class="text-slate-400">--</span>'}
                    </td>
                    <td class="py-3 px-4">
                        <span class="px-2 py-0.5 rounded-full text-[10px] font-semibold ${statusClass}">${escapeHtml(s.status)}</span>
                        ${s.isRto ? '<span class="ml-1 px-1.5 py-0.5 rounded text-[9px] font-semibold bg-rose-100 text-rose-700">RTO</span>' : ''}
                    </td>
                    <td class="py-3 px-4 text-xs text-slate-600">${eddDisplay}</td>
                    <td class="py-3 px-4">${delayDisplay}</td>
                    <td class="py-3 px-4">${slaDisplay}</td>
                    <td class="py-3 px-4 text-xs text-slate-500">${escapeHtml(s.lastUpdate) || 'N/A'}</td>
                    <td class="py-3 px-4">
                        <div class="flex items-center gap-0.5">
                            <button onclick="event.stopPropagation(); viewShipment('${escapeHtml(s.awb)}')" class="p-1.5 text-slate-400 hover:text-slate-900 hover:bg-slate-100 rounded" title="View Details">
                                <iconify-icon icon="solar:eye-linear" width="14"></iconify-icon>
                            </button>
                            <button onclick="event.stopPropagation(); refreshSingle('${escapeHtml(s.awb)}')" class="p-1.5 text-slate-400 hover:text-slate-900 hover:bg-slate-100 rounded" title="Refresh">
                                <iconify-icon icon="solar:refresh-linear" width="14"></iconify-icon>
                            </button>
                            ${s.delPod ? `<a href="${escapeHtml(s.delPod)}" target="_blank" onclick="event.stopPropagation()" class="p-1.5 text-slate-400 hover:text-emerald-600 hover:bg-emerald-50 rounded" title="View POD"><iconify-icon icon="solar:gallery-check-linear" width="14"></iconify-icon></a>` : ''}
                        </div>
                    </td>
                </tr>
            `}).join('');

            // Update footer
            footer.classList.remove('hidden');
            const serverDiv = document.getElementById('serverPagination');
            const prevServerBtn = document.getElementById('prevServerBtn');
            const nextServerBtn = document.getElementById('nextServerBtn');
            const serverPageInfo = document.getElementById('serverPageInfo');
            if (State.serverPagination) {
                if (serverDiv) serverDiv.classList.remove('hidden');
                const sp = State.serverPagination;
                const curPage = sp.pages[sp.pageIndex];
                const hasNext = curPage && curPage.nextAfter;
                if (prevServerBtn) prevServerBtn.disabled = sp.pageIndex <= 0;
                if (nextServerBtn) nextServerBtn.disabled = !hasNext;
                if (serverPageInfo) serverPageInfo.textContent = sp.totalApprox != null
                    ? `Page ${sp.pageIndex + 1} of ~${Math.ceil(sp.totalApprox / SERVER_PAGE_SIZE)} (${sp.totalApprox.toLocaleString()} total)`
                    : `Server page ${sp.pageIndex + 1}`;
                document.getElementById('tableStatus').textContent = sp.totalApprox != null
                    ? `Showing ${start + 1}-${Math.min(end, data.length)} of ${data.length} on this page (${sp.totalApprox.toLocaleString()} total in DB)`
                    : `Showing ${start + 1}-${Math.min(end, data.length)} of ${data.length} on this page`;
            } else {
                if (serverDiv) serverDiv.classList.add('hidden');
                document.getElementById('tableStatus').textContent = `Showing ${start + 1}-${Math.min(end, data.length)} of ${data.length} shipments`;
            }
            document.getElementById('pageInfo').textContent = `Page ${State.currentPage} of ${totalPages}`;
            document.getElementById('prevBtn').disabled = State.currentPage === 1;
            document.getElementById('nextBtn').disabled = State.currentPage === totalPages;

            subtitle.textContent = State.serverPagination && State.serverPagination.totalApprox != null
                ? `${State.serverPagination.totalApprox.toLocaleString()} shipments in DB (${data.length} on this page)`
                : `${data.length} shipment${data.length !== 1 ? 's' : ''} tracked`;
        }

        // Charts removed per latest requirement; KPIs and table remain active.

        /**
         * Get row class based on lifecycle status
         */
        function getLifecycleRowClass(shipment) {
            // Very dangerous RDC failure: highlight as hard failure (red)
            if (shipment.rdcDangerNoOfdToday) return 'row-failure';

            // RDC where OFD is >60 minutes late: warning (orange)
            if (shipment.rdcOfdLate) return 'row-breach';

            if (shipment.lifecycleBreach && shipment.isDelayed) return 'row-failure';
            if (shipment.lifecycleBreach) return 'row-breach';
            if (shipment.isDelayed && Math.abs(shipment.delayedDays) >= 3) return 'row-failure';
            return '';
        }

        /**
         * Format EDD for display
         */
        function formatEdd(edd) {
            if (!edd) return '<span class="text-slate-400">--</span>';
            // Format: "2025-07-07" -> "Jul 07"
            try {
                const date = parseApiDate(edd);
                if (date) {
                    const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                    return `${months[date.getMonth()]} ${String(date.getDate()).padStart(2, '0')}`;
                }
            } catch (e) {}
            return escapeHtml(edd);
        }

        /**
         * Format delayed days with color coding
         */
        function formatDelayDays(days) {
            if (days === null || days === undefined) {
                return '<span class="text-slate-400 text-xs">--</span>';
            }
            
            if (days < 0) {
                // Late/Delayed (negative = days past EDD)
                return `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-[10px] font-bold delay-negative">
                    <iconify-icon icon="solar:arrow-down-linear" width="10"></iconify-icon>
                    ${days}d
                </span>`;
            } else if (days > 0) {
                // Early (positive = days before EDD)
                return `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-[10px] font-semibold delay-positive">
                    <iconify-icon icon="solar:arrow-up-linear" width="10"></iconify-icon>
                    +${days}d
                </span>`;
            } else {
                // On time
                return `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-[10px] font-semibold delay-neutral">
                    <iconify-icon icon="solar:check-circle-linear" width="10"></iconify-icon>
                    0d
                </span>`;
            }
        }

        /**
         * Format SLA status badge
         */
        function formatSlaStatus(shipment) {
            const { terminalStatus, slaBreach, isDelayed, lifecycleBreach } = shipment;
            const isDelivered = terminalStatus && String(terminalStatus).toLowerCase() === 'delivered';

            if (isDelivered) {
                if (slaBreach || (shipment.delayedDays != null && shipment.delayedDays < 0)) {
                    return `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-[10px] font-semibold sla-delayed">
                        <iconify-icon icon="solar:clock-circle-linear" width="10"></iconify-icon>
                        Delayed
                    </span>`;
                }
                return `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-[10px] font-semibold sla-ontime">
                    <iconify-icon icon="solar:verified-check-linear" width="10"></iconify-icon>
                    On time
                </span>`;
            }
            if (lifecycleBreach || isDelayed) {
                return `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-[10px] font-semibold sla-breach">
                    <iconify-icon icon="solar:warning-linear" width="10"></iconify-icon>
                    ${lifecycleBreach ? 'Breach' : 'Delayed'}
                </span>`;
            }

            return `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-[10px] font-medium bg-slate-100 text-slate-600">
                <iconify-icon icon="solar:hourglass-linear" width="10"></iconify-icon>
                Pending
            </span>`;
        }

        function getRowClass(statusCode) {
            const classes = {
                'DELIVERED': 'row-delivered',
                'INTRANSIT': 'row-intransit',
                'OFD': 'row-ofd',
                'RTO': 'row-exception',
                'NDR': 'row-exception',
                'CANCELLED': '',
            };
            return classes[statusCode] || '';
        }

        function getStatusClass(statusCode) {
            const classes = {
                'DELIVERED': 'status-delivered',
                'INTRANSIT': 'status-intransit',
                'OFD': 'status-ofd',
                'RTO': 'status-rto',
                'NDR': 'status-ndr',
                'CANCELLED': 'status-cancelled',
            };
            return classes[statusCode] || 'bg-slate-100 text-slate-600';
        }

        // =====================================================
        // PAGINATION
        // =====================================================
        function prevPage() {
            if (State.currentPage > 1) {
                State.currentPage--;
                renderTable();
            }
        }

        function nextPage() {
            const totalPages = Math.ceil(State.filteredShipments.length / State.pageSize);
            if (State.currentPage < totalPages) {
                State.currentPage++;
                renderTable();
            }
        }

        // =====================================================
        // ACTIONS
        // =====================================================
        function viewShipment(awb) {
            window.location.href = `shipment.html?awb=${encodeURIComponent(awb)}`;
        }

        async function refreshSingle(awb) {
            setLoading(true, `Refreshing AWB: ${awb}`);
            try {
                const data = await API.tracking.getByAwb(awb);
                if (data) {
                    const shipment = normalizeShipmentData(data);
                    const index = State.shipments.findIndex(s => s.awb === awb);
                    if (index >= 0) {
                        State.shipments[index] = shipment;
                    }
                    // Persist updated data
                    DataLayer.saveCache(State.shipments);
                    
                    applyFiltersAndRender();
                    showToast(`AWB ${awb} refreshed`, 'success');
                }
            } catch (error) {
                handleApiError(error, awb);
            } finally {
                setLoading(false);
                updateRateLimitStatus();
            }
        }

        function refreshResults() {
            if (State.trackedAwbs.size === 0) {
                showToast('No AWBs to refresh', 'info');
                return;
            }
            
            const awbs = Array.from(State.trackedAwbs);
            document.getElementById('bulkAwbInput').value = awbs.join(', ');
            trackBulkAWB();
        }

        // =====================================================
        // EXPORT
        // =====================================================
        function exportData() {
            if (State.filteredShipments.length === 0) {
                showToast('No data to export', 'error');
                return;
            }

            const headers = ['AWB', 'Order Number', 'Customer', 'Origin', 'Destination', 'Current Location', 'Type', 'Value', 'Status', 'Last Update', 'Added On', 'Weight', 'Is RTO'];
            const rows = State.filteredShipments.map(s => [
                s.awb, s.orderNumber, s.customer, s.origin, s.destination, s.currentLocation, s.type, s.value, s.status, s.lastUpdate, s.addedOn, s.weight, s.isRto
            ]);
            
            const csv = [headers, ...rows]
                .map(r => r.map(v => `"${String(v || '').replace(/"/g, '""')}"`).join(','))
                .join('\n');

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `urbanebolt-shipments-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast(`Exported ${State.filteredShipments.length} records`, 'success');
        }

        // =====================================================
        // UTILITIES
        // =====================================================
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }
    </script>
</body>
</html>
